<!DOCTYPE html>
<html lang="nl">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <meta name="apple-mobile-web-app-capable" content="yes">
    <meta name="apple-mobile-web-app-status-bar-style" content="black">
    <title>Podcast Transcriber</title>
    <link rel="icon" type="image/svg+xml" href="data:image/svg+xml,<svg xmlns='http://www.w3.org/2000/svg' viewBox='0 0 32 32'><rect fill='%23000' width='32' height='32'/><text x='16' y='22' text-anchor='middle' fill='%23FFD700' font-size='18' font-family='system-ui'>üéôÔ∏è</text></svg>">
    <style>
        * {
            box-sizing: border-box;
            margin: 0;
            padding: 0;
        }

        body {
            font-family: -apple-system, BlinkMacSystemFont, 'Segoe UI', Roboto, sans-serif;
            background: #000;
            color: #fff;
            min-height: 100vh;
            padding: 20px;
        }

        .container {
            max-width: 800px;
            margin: 0 auto;
        }

        header {
            text-align: center;
            margin-bottom: 30px;
        }

        header h1 {
            font-size: 1.8rem;
            margin-bottom: 10px;
        }

        header p {
            color: #888;
            font-size: 0.95rem;
        }

        /* API Key section */
        .api-key-section {
            background: rgba(255, 255, 255, 0.05);
            border-radius: 12px;
            padding: 20px;
            margin-bottom: 20px;
        }

        .api-key-section label {
            display: block;
            margin-bottom: 8px;
            color: #aaa;
            font-size: 0.9rem;
        }

        .api-key-row {
            display: flex;
            gap: 10px;
        }

        .api-key-input {
            flex: 1;
            background: rgba(255, 255, 255, 0.1);
            border: 1px solid rgba(255, 255, 255, 0.2);
            border-radius: 8px;
            padding: 12px 16px;
            color: #fff;
            font-size: 0.95rem;
        }

        .api-key-input:focus {
            outline: none;
            border-color: #e94560;
        }

        .save-btn {
            background: #e94560;
            border: none;
            color: #fff;
            padding: 12px 24px;
            border-radius: 8px;
            cursor: pointer;
            font-size: 0.95rem;
            font-weight: 500;
            transition: background 0.2s;
        }

        .save-btn:hover {
            background: #ff6b6b;
        }

        .api-key-hint {
            margin-top: 8px;
            font-size: 0.8rem;
            color: #666;
        }

        .api-key-hint a {
            color: #e94560;
            text-decoration: none;
        }

        /* Drop zone */
        .drop-zone {
            border: 2px dashed rgba(255, 255, 255, 0.3);
            border-radius: 16px;
            padding: 60px 40px;
            text-align: center;
            cursor: pointer;
            transition: all 0.3s;
            background: rgba(255, 255, 255, 0.02);
            margin-bottom: 20px;
        }

        .drop-zone:hover,
        .drop-zone.drag-over {
            border-color: #e94560;
            background: rgba(233, 69, 96, 0.1);
        }

        .drop-zone-icon {
            font-size: 3rem;
            margin-bottom: 20px;
        }

        .drop-zone-text {
            font-size: 1.1rem;
            color: #aaa;
            margin-bottom: 10px;
        }

        .drop-zone-hint {
            font-size: 0.85rem;
            color: #666;
        }

        /* Options */
        .options {
            display: flex;
            gap: 20px;
            margin-bottom: 20px;
            flex-wrap: wrap;
        }

        .option-toggle {
            display: flex;
            align-items: center;
            gap: 10px;
            background: rgba(255, 255, 255, 0.05);
            padding: 12px 16px;
            border-radius: 8px;
            cursor: pointer;
            user-select: none;
        }

        .option-toggle:hover {
            background: rgba(255, 255, 255, 0.1);
        }

        .toggle-switch {
            width: 44px;
            height: 24px;
            background: rgba(255, 255, 255, 0.2);
            border-radius: 12px;
            position: relative;
            transition: background 0.2s;
        }

        .toggle-switch::after {
            content: '';
            position: absolute;
            width: 20px;
            height: 20px;
            background: #fff;
            border-radius: 50%;
            top: 2px;
            left: 2px;
            transition: transform 0.2s;
        }

        .option-toggle.active .toggle-switch {
            background: #e94560;
        }

        .option-toggle.active .toggle-switch::after {
            transform: translateX(20px);
        }

        .option-label {
            color: #ccc;
            font-size: 0.9rem;
        }

        /* Status */
        .status {
            background: rgba(255, 255, 255, 0.05);
            border-radius: 12px;
            padding: 20px;
            margin-bottom: 20px;
            display: none;
        }

        .status.show {
            display: block;
        }

        .status-header {
            display: flex;
            justify-content: space-between;
            align-items: center;
            margin-bottom: 15px;
        }

        .status-title {
            font-weight: 600;
            color: #fff;
        }

        .status-subtitle {
            color: #888;
            font-size: 0.85rem;
            margin-top: 4px;
        }

        .cancel-btn {
            background: rgba(255, 255, 255, 0.1);
            border: 1px solid rgba(255, 255, 255, 0.2);
            color: #fff;
            padding: 8px 16px;
            border-radius: 6px;
            cursor: pointer;
            font-size: 0.85rem;
        }

        .cancel-btn:hover {
            background: rgba(255, 255, 255, 0.2);
        }

        .progress-bar-container {
            height: 6px;
            background: rgba(255, 255, 255, 0.1);
            border-radius: 3px;
            overflow: hidden;
        }

        .progress-bar {
            height: 100%;
            background: #e94560;
            width: 0%;
            transition: width 0.3s;
        }

        .progress-bar.indeterminate {
            width: 30%;
            animation: indeterminate 1.5s infinite ease-in-out;
        }

        @keyframes indeterminate {
            0% { transform: translateX(-100%); }
            100% { transform: translateX(400%); }
        }

        .status-text {
            margin-top: 10px;
            color: #888;
            font-size: 0.85rem;
        }

        /* Output */
        .output {
            display: none;
        }

        .output.show {
            display: block;
        }

        .output-header {
            display: flex;
            justify-content: space-between;
            align-items: center;
            margin-bottom: 15px;
            flex-wrap: wrap;
            gap: 10px;
        }

        .output-title {
            font-size: 1.1rem;
            font-weight: 600;
        }

        .output-actions {
            display: flex;
            gap: 10px;
            flex-wrap: wrap;
        }

        .action-btn {
            background: rgba(255, 255, 255, 0.1);
            border: 1px solid rgba(255, 255, 255, 0.2);
            color: #fff;
            padding: 10px 16px;
            border-radius: 8px;
            cursor: pointer;
            font-size: 0.9rem;
            transition: all 0.2s;
            display: flex;
            align-items: center;
            gap: 8px;
            text-decoration: none;
        }

        .action-btn:hover {
            background: rgba(255, 255, 255, 0.2);
        }

        .action-btn.primary {
            background: #e94560;
            border-color: #e94560;
        }

        .action-btn.primary:hover {
            background: #ff6b6b;
        }

        .transcript-box {
            background: rgba(255, 255, 255, 0.05);
            border-radius: 12px;
            padding: 20px;
            max-height: 500px;
            overflow-y: auto;
            line-height: 1.7;
            font-size: 0.95rem;
            color: #ddd;
            white-space: pre-wrap;
        }

        /* Episode info */
        .episode-info {
            background: rgba(233, 69, 96, 0.1);
            border-left: 3px solid #e94560;
            padding: 15px;
            border-radius: 0 8px 8px 0;
            margin-bottom: 20px;
            display: none;
        }

        .episode-info.show {
            display: block;
        }

        .episode-title {
            font-weight: 600;
            margin-bottom: 5px;
        }

        .episode-meta {
            color: #888;
            font-size: 0.85rem;
        }

        /* Toast */
        .toast {
            position: fixed;
            bottom: 30px;
            left: 50%;
            transform: translateX(-50%) translateY(50px);
            background: #333;
            color: #fff;
            padding: 12px 24px;
            border-radius: 8px;
            opacity: 0;
            transition: all 0.3s;
            z-index: 100;
        }

        .toast.error {
            background: #e94560;
        }

        .toast.show {
            opacity: 1;
            transform: translateX(-50%) translateY(0);
        }

        /* Mobile */
        @media (max-width: 600px) {
            body {
                padding: 15px;
            }

            header h1 {
                font-size: 1.5rem;
            }

            .drop-zone {
                padding: 40px 20px;
            }

            .api-key-row {
                flex-direction: column;
            }

            .output-actions {
                width: 100%;
            }

            .action-btn {
                flex: 1;
                justify-content: center;
            }
        }
    </style>
</head>
<body>
    <div class="container">
        <header>
            <h1>üéôÔ∏è Podcast Transcriber</h1>
            <p>Transcribeer podcasts met AI (Nederlands, Engels, Spaans)</p>
        </header>

        <!-- API Key Section -->
        <div class="api-key-section">
            <label for="apiKey">OpenAI API Key</label>
            <div class="api-key-row">
                <input type="password" id="apiKey" class="api-key-input" placeholder="sk-...">
                <button class="save-btn" id="saveApiKey">Opslaan</button>
            </div>
            <div class="api-key-hint">
                Nog geen API key? <a href="https://platform.openai.com/api-keys" target="_blank">Maak er een aan bij OpenAI</a>
            </div>
        </div>

        <!-- Drop Zone -->
        <div class="drop-zone" id="dropZone">
            <div class="drop-zone-icon">üîó</div>
            <div class="drop-zone-text">Plak of drop een podcast URL hier</div>
            <div class="drop-zone-hint">Ondersteunt: MP3 links, RSS feeds (pakt nieuwste aflevering)</div>
        </div>

        <!-- Options -->
        <div class="options">
            <label class="option-toggle" id="translateToggle">
                <div class="toggle-switch"></div>
                <span class="option-label">Vertaal naar Nederlands (als niet al NL)</span>
            </label>
        </div>

        <!-- Episode Info -->
        <div class="episode-info" id="episodeInfo">
            <div class="episode-title" id="episodeTitle"></div>
            <div class="episode-meta" id="episodeMeta"></div>
        </div>

        <!-- Status -->
        <div class="status" id="status">
            <div class="status-header">
                <div>
                    <div class="status-title" id="statusTitle">Bezig...</div>
                    <div class="status-subtitle" id="statusSubtitle"></div>
                </div>
                <button class="cancel-btn" id="cancelBtn">Annuleren</button>
            </div>
            <div class="progress-bar-container">
                <div class="progress-bar" id="progressBar"></div>
            </div>
            <div class="status-text" id="statusText"></div>
        </div>

        <!-- Output -->
        <div class="output" id="output">
            <div class="output-header">
                <div class="output-title">Transcriptie</div>
                <div class="output-actions">
                    <button class="action-btn" id="copyBtn">üìã Kopieer</button>
                    <a class="action-btn primary" id="speedreaderBtn" href="#" target="_blank">‚ö° Open in Speedreader</a>
                </div>
            </div>
            <div class="transcript-box" id="transcript"></div>
        </div>
    </div>

    <!-- Toast -->
    <div class="toast" id="toast"></div>

    <script>
        // State
        const state = {
            apiKey: '',
            translateToNL: false,
            abortController: null,
            transcriptText: ''
        };

        // DOM elements
        const apiKeyInput = document.getElementById('apiKey');
        const saveApiKeyBtn = document.getElementById('saveApiKey');
        const dropZone = document.getElementById('dropZone');
        const translateToggle = document.getElementById('translateToggle');
        const statusEl = document.getElementById('status');
        const statusTitle = document.getElementById('statusTitle');
        const statusSubtitle = document.getElementById('statusSubtitle');
        const statusText = document.getElementById('statusText');
        const progressBar = document.getElementById('progressBar');
        const cancelBtn = document.getElementById('cancelBtn');
        const outputEl = document.getElementById('output');
        const transcriptEl = document.getElementById('transcript');
        const copyBtn = document.getElementById('copyBtn');
        const speedreaderBtn = document.getElementById('speedreaderBtn');
        const episodeInfo = document.getElementById('episodeInfo');
        const episodeTitle = document.getElementById('episodeTitle');
        const episodeMeta = document.getElementById('episodeMeta');
        const toast = document.getElementById('toast');

        // CORS proxy
        const CORS_PROXY = 'https://api.allorigins.win/raw?url=';

        // Initialize
        const init = () => {
            loadApiKey();
            setupEventListeners();
            checkUrlParam();
        };

        // Load API key from localStorage
        const loadApiKey = () => {
            const savedKey = localStorage.getItem('transcriber_api_key');
            if (savedKey) {
                state.apiKey = savedKey;
                apiKeyInput.value = savedKey;
            }
        };

        // Save API key to localStorage
        const saveApiKey = () => {
            const key = apiKeyInput.value.trim();
            if (key) {
                state.apiKey = key;
                localStorage.setItem('transcriber_api_key', key);
                showToast('API key opgeslagen');
            }
        };

        // Setup event listeners
        const setupEventListeners = () => {
            saveApiKeyBtn.addEventListener('click', saveApiKey);
            apiKeyInput.addEventListener('keypress', (e) => {
                if (e.key === 'Enter') saveApiKey();
            });

            // Drop zone
            dropZone.addEventListener('click', handleDropZoneClick);
            dropZone.addEventListener('dragover', handleDragOver);
            dropZone.addEventListener('dragleave', handleDragLeave);
            dropZone.addEventListener('drop', handleDrop);

            // Global paste
            document.addEventListener('paste', handlePaste);

            // Toggle
            translateToggle.addEventListener('click', () => {
                state.translateToNL = !state.translateToNL;
                translateToggle.classList.toggle('active', state.translateToNL);
            });

            // Cancel button
            cancelBtn.addEventListener('click', cancelTranscription);

            // Copy button
            copyBtn.addEventListener('click', copyTranscript);
        };

        // Handle drop zone click
        const handleDropZoneClick = async () => {
            try {
                const text = await navigator.clipboard.readText();
                if (text.trim()) {
                    processUrl(text.trim());
                } else {
                    showToast('Klembord is leeg', true);
                }
            } catch (err) {
                showToast('Kan klembord niet lezen. Plak met Ctrl+V', true);
            }
        };

        // Handle drag over
        const handleDragOver = (e) => {
            e.preventDefault();
            dropZone.classList.add('drag-over');
        };

        // Handle drag leave
        const handleDragLeave = () => {
            dropZone.classList.remove('drag-over');
        };

        // Handle drop
        const handleDrop = (e) => {
            e.preventDefault();
            dropZone.classList.remove('drag-over');
            const text = e.dataTransfer.getData('text/plain') || e.dataTransfer.getData('text/uri-list');
            if (text) {
                processUrl(text.trim());
            }
        };

        // Handle paste
        const handlePaste = (e) => {
            const text = e.clipboardData.getData('text/plain');
            if (text && text.trim()) {
                e.preventDefault();
                processUrl(text.trim());
            }
        };

        // Check URL parameter
        const checkUrlParam = () => {
            const params = new URLSearchParams(window.location.search);
            const url = params.get('url');
            if (url) {
                processUrl(url);
            }
        };

        // Process URL
        const processUrl = async (url) => {
            // Validate it's a URL
            if (!isValidUrl(url)) {
                showToast('Ongeldige URL', true);
                return;
            }

            // Check API key
            if (!state.apiKey) {
                showToast('Voer eerst je OpenAI API key in', true);
                apiKeyInput.focus();
                return;
            }

            // Reset output
            outputEl.classList.remove('show');
            episodeInfo.classList.remove('show');

            try {
                state.abortController = new AbortController();
                showStatus('URL analyseren...', '', 'indeterminate');

                // Determine if RSS or direct MP3
                let audioUrl = url;
                let episodeData = null;

                if (isRssUrl(url)) {
                    updateStatus('RSS feed ophalen...');
                    episodeData = await fetchLatestEpisode(url);
                    audioUrl = episodeData.audioUrl;
                    showEpisodeInfo(episodeData);
                } else if (!isAudioUrl(url)) {
                    // Try to fetch and check if it's RSS
                    updateStatus('Inhoud controleren...');
                    const content = await fetchWithCors(url);
                    if (content.includes('<rss') || content.includes('<feed')) {
                        episodeData = parseRssFeed(content);
                        audioUrl = episodeData.audioUrl;
                        showEpisodeInfo(episodeData);
                    } else {
                        showToast('URL is geen podcast feed of audio bestand', true);
                        hideStatus();
                        return;
                    }
                }

                // Download audio
                updateStatus('Audio downloaden...', getFilename(audioUrl));
                const audioBlob = await downloadAudio(audioUrl);

                // Transcribe
                updateStatus('Transcriberen...', 'Dit kan even duren');
                setProgress(0);
                const transcript = await transcribeAudio(audioBlob);

                // Optionally translate
                let finalText = transcript;
                if (state.translateToNL && !isLikelyDutch(transcript)) {
                    updateStatus('Vertalen naar Nederlands...');
                    finalText = await translateToNL(transcript);
                }

                // Show result
                showResult(finalText);
                hideStatus();

            } catch (err) {
                if (err.name === 'AbortError') {
                    showToast('Geannuleerd');
                } else {
                    console.error('Error:', err);
                    showToast(err.message || 'Er ging iets mis', true);
                }
                hideStatus();
            }
        };

        // Validate URL
        const isValidUrl = (str) => {
            try {
                const url = new URL(str);
                return url.protocol === 'http:' || url.protocol === 'https:';
            } catch {
                return false;
            }
        };

        // Check if likely RSS URL
        const isRssUrl = (url) => {
            const lower = url.toLowerCase();
            return lower.includes('/feed') || lower.includes('/rss') ||
                   lower.includes('.xml') || lower.includes('feed=');
        };

        // Check if audio URL
        const isAudioUrl = (url) => {
            const lower = url.toLowerCase();
            return lower.includes('.mp3') || lower.includes('.m4a') ||
                   lower.includes('.wav') || lower.includes('.ogg') ||
                   lower.includes('audio');
        };

        // Get filename from URL
        const getFilename = (url) => {
            try {
                const pathname = new URL(url).pathname;
                const parts = pathname.split('/');
                return parts[parts.length - 1] || 'audio';
            } catch {
                return 'audio';
            }
        };

        // Fetch with CORS proxy
        const fetchWithCors = async (url) => {
            const response = await fetch(CORS_PROXY + encodeURIComponent(url), {
                signal: state.abortController?.signal
            });
            if (!response.ok) throw new Error('Kon URL niet ophalen');
            return await response.text();
        };

        // Fetch latest episode from RSS feed
        const fetchLatestEpisode = async (feedUrl) => {
            const content = await fetchWithCors(feedUrl);
            return parseRssFeed(content);
        };

        // Parse RSS feed and get latest episode
        const parseRssFeed = (xml) => {
            const parser = new DOMParser();
            const doc = parser.parseFromString(xml, 'text/xml');

            // Find first item/entry with audio enclosure
            const items = doc.querySelectorAll('item, entry');

            for (const item of items) {
                // Try enclosure tag (RSS 2.0)
                const enclosure = item.querySelector('enclosure[type^="audio"], enclosure[url*=".mp3"], enclosure[url*=".m4a"]');
                if (enclosure) {
                    return {
                        title: item.querySelector('title')?.textContent || 'Onbekende aflevering',
                        pubDate: item.querySelector('pubDate')?.textContent || '',
                        audioUrl: enclosure.getAttribute('url')
                    };
                }

                // Try media:content tag
                const mediaContent = item.querySelector('content[type^="audio"], content[url*=".mp3"]');
                if (mediaContent) {
                    return {
                        title: item.querySelector('title')?.textContent || 'Onbekende aflevering',
                        pubDate: item.querySelector('pubDate, published')?.textContent || '',
                        audioUrl: mediaContent.getAttribute('url')
                    };
                }

                // Try link ending in audio extension
                const links = item.querySelectorAll('link');
                for (const link of links) {
                    const href = link.getAttribute('href') || link.textContent;
                    if (href && (href.includes('.mp3') || href.includes('.m4a'))) {
                        return {
                            title: item.querySelector('title')?.textContent || 'Onbekende aflevering',
                            pubDate: item.querySelector('pubDate, published')?.textContent || '',
                            audioUrl: href
                        };
                    }
                }
            }

            throw new Error('Geen audio gevonden in feed');
        };

        // Show episode info
        const showEpisodeInfo = (data) => {
            episodeTitle.textContent = data.title;
            episodeMeta.textContent = data.pubDate ? `Gepubliceerd: ${formatDate(data.pubDate)}` : '';
            episodeInfo.classList.add('show');
        };

        // Format date
        const formatDate = (dateStr) => {
            try {
                const date = new Date(dateStr);
                return date.toLocaleDateString('nl-NL', {
                    year: 'numeric',
                    month: 'long',
                    day: 'numeric'
                });
            } catch {
                return dateStr;
            }
        };

        // Download audio file
        const downloadAudio = async (url) => {
            // Try direct fetch first
            try {
                const response = await fetch(url, {
                    signal: state.abortController?.signal
                });
                if (response.ok) {
                    return await response.blob();
                }
            } catch (e) {
                // If CORS error, try with proxy
            }

            // Try with CORS proxy
            const response = await fetch(CORS_PROXY + encodeURIComponent(url), {
                signal: state.abortController?.signal
            });
            if (!response.ok) throw new Error('Kon audio niet downloaden');
            return await response.blob();
        };

        // Transcribe audio using OpenAI Whisper
        const transcribeAudio = async (audioBlob) => {
            const formData = new FormData();
            formData.append('file', audioBlob, 'audio.mp3');
            formData.append('model', 'whisper-1');
            formData.append('response_format', 'text');

            const response = await fetch('https://api.openai.com/v1/audio/transcriptions', {
                method: 'POST',
                headers: {
                    'Authorization': `Bearer ${state.apiKey}`
                },
                body: formData,
                signal: state.abortController?.signal
            });

            if (!response.ok) {
                const error = await response.json().catch(() => ({}));
                if (response.status === 401) {
                    throw new Error('Ongeldige API key');
                }
                throw new Error(error.error?.message || 'Transcriptie mislukt');
            }

            return await response.text();
        };

        // Translate to Dutch using OpenAI
        const translateToNL = async (text) => {
            const response = await fetch('https://api.openai.com/v1/chat/completions', {
                method: 'POST',
                headers: {
                    'Authorization': `Bearer ${state.apiKey}`,
                    'Content-Type': 'application/json'
                },
                body: JSON.stringify({
                    model: 'gpt-4o-mini',
                    messages: [
                        {
                            role: 'system',
                            content: 'Je bent een vertaler. Vertaal de volgende tekst naar Nederlands. Behoud de oorspronkelijke opmaak en alinea\'s. Geef alleen de vertaling terug, geen uitleg.'
                        },
                        {
                            role: 'user',
                            content: text
                        }
                    ],
                    temperature: 0.3
                }),
                signal: state.abortController?.signal
            });

            if (!response.ok) {
                const error = await response.json().catch(() => ({}));
                throw new Error(error.error?.message || 'Vertaling mislukt');
            }

            const data = await response.json();
            return data.choices[0]?.message?.content || text;
        };

        // Simple check if text is likely Dutch
        const isLikelyDutch = (text) => {
            const dutchWords = ['de', 'het', 'een', 'van', 'en', 'in', 'dat', 'op', 'te', 'voor', 'met', 'zijn', 'er', 'aan', 'om', 'ook', 'als', 'maar', 'bij', 'dan', 'nog', 'wel', 'geen', 'meer', 'al', 'nu'];
            const words = text.toLowerCase().split(/\s+/).slice(0, 200);
            const matches = words.filter(w => dutchWords.includes(w)).length;
            return matches / words.length > 0.1;
        };

        // Show status
        const showStatus = (title, subtitle = '', progressType = 'indeterminate') => {
            statusTitle.textContent = title;
            statusSubtitle.textContent = subtitle;
            statusText.textContent = '';
            progressBar.className = 'progress-bar ' + progressType;
            if (progressType === 'indeterminate') {
                progressBar.style.width = '30%';
            }
            statusEl.classList.add('show');
        };

        // Update status
        const updateStatus = (title, subtitle = '') => {
            statusTitle.textContent = title;
            if (subtitle) statusSubtitle.textContent = subtitle;
        };

        // Set progress
        const setProgress = (percent) => {
            progressBar.className = 'progress-bar';
            progressBar.style.width = percent + '%';
        };

        // Hide status
        const hideStatus = () => {
            statusEl.classList.remove('show');
            state.abortController = null;
        };

        // Cancel transcription
        const cancelTranscription = () => {
            if (state.abortController) {
                state.abortController.abort();
            }
        };

        // Show result
        const showResult = (text) => {
            state.transcriptText = text;
            transcriptEl.textContent = text;

            // Update speedreader link
            const speedreaderUrl = new URL('/speedreader/', window.location.origin);
            speedreaderUrl.searchParams.set('text', text.substring(0, 10000)); // Limit for URL length
            speedreaderBtn.href = speedreaderUrl.toString();

            outputEl.classList.add('show');
        };

        // Copy transcript
        const copyTranscript = async () => {
            try {
                await navigator.clipboard.writeText(state.transcriptText);
                showToast('Gekopieerd naar klembord');
            } catch (err) {
                showToast('Kopi√´ren mislukt', true);
            }
        };

        // Show toast
        const showToast = (message, isError = false) => {
            toast.textContent = message;
            toast.className = 'toast' + (isError ? ' error' : '');
            toast.classList.add('show');
            setTimeout(() => toast.classList.remove('show'), 3000);
        };

        // Initialize
        init();
    </script>
</body>
</html>
