<!DOCTYPE html>
<html lang="nl">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <meta name="apple-mobile-web-app-capable" content="yes">
    <meta name="apple-mobile-web-app-status-bar-style" content="black">
    <title>Podcast Transcriber</title>
    <link rel="icon" type="image/svg+xml" href="data:image/svg+xml,<svg xmlns='http://www.w3.org/2000/svg' viewBox='0 0 32 32'><rect fill='%23000' width='32' height='32'/><text x='16' y='22' text-anchor='middle' fill='%23FFD700' font-size='18' font-family='system-ui'>üéôÔ∏è</text></svg>">
    <style>
        * {
            box-sizing: border-box;
            margin: 0;
            padding: 0;
        }

        body {
            font-family: -apple-system, BlinkMacSystemFont, 'Segoe UI', Roboto, sans-serif;
            background: #000;
            color: #fff;
            min-height: 100vh;
            padding: 20px;
        }

        .container {
            max-width: 800px;
            margin: 0 auto;
        }

        header {
            text-align: center;
            margin-bottom: 30px;
        }

        header h1 {
            font-size: 1.8rem;
            margin-bottom: 10px;
        }

        header p {
            color: #888;
            font-size: 0.95rem;
        }

        /* API Key section */
        .api-key-section {
            background: rgba(255, 255, 255, 0.05);
            border-radius: 12px;
            padding: 20px;
            margin-bottom: 20px;
        }

        .api-key-section label {
            display: block;
            margin-bottom: 8px;
            color: #aaa;
            font-size: 0.9rem;
        }

        .api-key-row {
            display: flex;
            gap: 10px;
        }

        .api-key-input {
            flex: 1;
            background: rgba(255, 255, 255, 0.1);
            border: 1px solid rgba(255, 255, 255, 0.2);
            border-radius: 8px;
            padding: 12px 16px;
            color: #fff;
            font-size: 0.95rem;
        }

        .api-key-input:focus {
            outline: none;
            border-color: #e94560;
        }

        .save-btn {
            background: #e94560;
            border: none;
            color: #fff;
            padding: 12px 24px;
            border-radius: 8px;
            cursor: pointer;
            font-size: 0.95rem;
            font-weight: 500;
            transition: background 0.2s;
        }

        .save-btn:hover {
            background: #ff6b6b;
        }

        .save-btn.saved {
            background: #2ecc71;
        }

        .api-key-section.has-key {
            border: 1px solid rgba(46, 204, 113, 0.3);
        }

        .api-key-status {
            display: none;
            align-items: center;
            gap: 6px;
            margin-top: 8px;
            font-size: 0.85rem;
            color: #2ecc71;
        }

        .api-key-section.has-key .api-key-status {
            display: flex;
        }

        .api-key-hint {
            margin-top: 8px;
            font-size: 0.8rem;
            color: #666;
        }

        .api-key-hint a {
            color: #e94560;
            text-decoration: none;
        }

        /* Drop zone */
        .drop-zone {
            border: 2px dashed rgba(255, 255, 255, 0.3);
            border-radius: 16px;
            padding: 60px 40px;
            text-align: center;
            cursor: pointer;
            transition: all 0.3s;
            background: rgba(255, 255, 255, 0.02);
            margin-bottom: 20px;
        }

        .drop-zone:hover,
        .drop-zone.drag-over {
            border-color: #e94560;
            background: rgba(233, 69, 96, 0.1);
        }

        .drop-zone-icon {
            font-size: 3rem;
            margin-bottom: 20px;
        }

        .drop-zone-text {
            font-size: 1.1rem;
            color: #aaa;
            margin-bottom: 10px;
        }

        .drop-zone-hint {
            font-size: 0.85rem;
            color: #666;
        }

        /* Options */
        .options {
            display: flex;
            gap: 20px;
            margin-bottom: 20px;
            flex-wrap: wrap;
        }

        .option-toggle {
            display: flex;
            align-items: center;
            gap: 10px;
            background: rgba(255, 255, 255, 0.05);
            padding: 12px 16px;
            border-radius: 8px;
            cursor: pointer;
            user-select: none;
        }

        .option-toggle:hover {
            background: rgba(255, 255, 255, 0.1);
        }

        .toggle-switch {
            width: 44px;
            height: 24px;
            background: rgba(255, 255, 255, 0.2);
            border-radius: 12px;
            position: relative;
            transition: background 0.2s;
        }

        .toggle-switch::after {
            content: '';
            position: absolute;
            width: 20px;
            height: 20px;
            background: #fff;
            border-radius: 50%;
            top: 2px;
            left: 2px;
            transition: transform 0.2s;
        }

        .option-toggle.active .toggle-switch {
            background: #e94560;
        }

        .option-toggle.active .toggle-switch::after {
            transform: translateX(20px);
        }

        .option-label {
            color: #ccc;
            font-size: 0.9rem;
        }

        /* Status */
        .status {
            background: rgba(255, 255, 255, 0.05);
            border-radius: 12px;
            padding: 20px;
            margin-bottom: 20px;
            display: none;
        }

        .status.show {
            display: block;
        }

        .status-header {
            display: flex;
            justify-content: space-between;
            align-items: center;
            margin-bottom: 15px;
        }

        .status-title {
            font-weight: 600;
            color: #fff;
        }

        .status-subtitle {
            color: #888;
            font-size: 0.85rem;
            margin-top: 4px;
        }

        .cancel-btn {
            background: rgba(255, 255, 255, 0.1);
            border: 1px solid rgba(255, 255, 255, 0.2);
            color: #fff;
            padding: 8px 16px;
            border-radius: 6px;
            cursor: pointer;
            font-size: 0.85rem;
        }

        .cancel-btn:hover {
            background: rgba(255, 255, 255, 0.2);
        }

        .progress-bar-container {
            height: 6px;
            background: rgba(255, 255, 255, 0.1);
            border-radius: 3px;
            overflow: hidden;
        }

        .progress-bar {
            height: 100%;
            background: #e94560;
            width: 0%;
            transition: width 0.3s;
        }

        .progress-bar.indeterminate {
            width: 30%;
            animation: indeterminate 1.5s infinite ease-in-out;
        }

        @keyframes indeterminate {
            0% { transform: translateX(-100%); }
            100% { transform: translateX(400%); }
        }

        .status-text {
            margin-top: 10px;
            color: #888;
            font-size: 0.85rem;
        }

        /* Output */
        .output {
            display: none;
        }

        .output.show {
            display: block;
        }

        .output-header {
            display: flex;
            justify-content: space-between;
            align-items: center;
            margin-bottom: 15px;
            flex-wrap: wrap;
            gap: 10px;
        }

        .output-title {
            font-size: 1.1rem;
            font-weight: 600;
        }

        .output-actions {
            display: flex;
            gap: 10px;
            flex-wrap: wrap;
        }

        .action-btn {
            background: rgba(255, 255, 255, 0.1);
            border: 1px solid rgba(255, 255, 255, 0.2);
            color: #fff;
            padding: 10px 16px;
            border-radius: 8px;
            cursor: pointer;
            font-size: 0.9rem;
            transition: all 0.2s;
            display: flex;
            align-items: center;
            gap: 8px;
            text-decoration: none;
        }

        .action-btn:hover {
            background: rgba(255, 255, 255, 0.2);
        }

        .action-btn.primary {
            background: #e94560;
            border-color: #e94560;
        }

        .action-btn.primary:hover {
            background: #ff6b6b;
        }

        .transcript-box {
            background: rgba(255, 255, 255, 0.05);
            border-radius: 12px;
            padding: 20px;
            max-height: 500px;
            overflow-y: auto;
            line-height: 1.7;
            font-size: 0.95rem;
            color: #ddd;
        }

        /* Chapters */
        .chapters {
            background: rgba(255, 255, 255, 0.05);
            border-radius: 12px;
            padding: 15px;
            margin-bottom: 15px;
            display: none;
        }

        .chapters.show {
            display: block;
        }

        .chapters-title {
            font-weight: 600;
            margin-bottom: 10px;
            color: #fff;
        }

        .chapter-item {
            display: flex;
            gap: 12px;
            padding: 8px 0;
            border-bottom: 1px solid rgba(255, 255, 255, 0.1);
            cursor: pointer;
        }

        .chapter-item:last-child {
            border-bottom: none;
        }

        .chapter-item:hover {
            background: rgba(255, 255, 255, 0.05);
            margin: 0 -15px;
            padding: 8px 15px;
        }

        .chapter-time {
            color: #e94560;
            font-family: monospace;
            font-size: 0.85rem;
            min-width: 50px;
        }

        .chapter-name {
            color: #ccc;
            font-size: 0.9rem;
        }

        /* Transcript segments with timestamps */
        .segment {
            margin-bottom: 12px;
        }

        .segment-time {
            color: #e94560;
            font-family: monospace;
            font-size: 0.8rem;
            margin-right: 8px;
            cursor: pointer;
        }

        .segment-time:hover {
            text-decoration: underline;
        }

        .segment-text {
            color: #ddd;
        }

        /* File input */
        .file-input {
            display: none;
        }

        .url-input-row {
            display: flex;
            gap: 10px;
            width: 100%;
            max-width: 500px;
            margin-bottom: 15px;
        }

        .url-input {
            flex: 1;
            background: rgba(255, 255, 255, 0.1);
            border: 1px solid rgba(255, 255, 255, 0.2);
            border-radius: 8px;
            padding: 12px 16px;
            color: #fff;
            font-size: 0.95rem;
        }

        .url-input:focus {
            outline: none;
            border-color: #e94560;
        }

        .url-input::placeholder {
            color: #666;
        }

        .go-btn {
            background: #e94560;
            border: none;
            color: #fff;
            padding: 12px 20px;
            border-radius: 8px;
            cursor: pointer;
            font-size: 0.95rem;
            font-weight: 500;
        }

        .go-btn:hover {
            background: #ff6b6b;
        }

        .file-select-btn {
            margin-top: 10px;
            background: rgba(255, 255, 255, 0.1);
            border: 1px solid rgba(255, 255, 255, 0.2);
            color: #aaa;
            padding: 8px 16px;
            border-radius: 6px;
            cursor: pointer;
            font-size: 0.85rem;
        }

        .file-select-btn:hover {
            background: rgba(255, 255, 255, 0.2);
            color: #fff;
        }

        /* Episode info */
        .episode-info {
            background: rgba(233, 69, 96, 0.1);
            border-left: 3px solid #e94560;
            padding: 15px;
            border-radius: 0 8px 8px 0;
            margin-bottom: 20px;
            display: none;
        }

        .episode-info.show {
            display: block;
        }

        .episode-title {
            font-weight: 600;
            margin-bottom: 5px;
        }

        .episode-meta {
            color: #888;
            font-size: 0.85rem;
        }

        /* Toast */
        .toast {
            position: fixed;
            bottom: 30px;
            left: 50%;
            transform: translateX(-50%) translateY(50px);
            background: #333;
            color: #fff;
            padding: 12px 24px;
            border-radius: 8px;
            opacity: 0;
            transition: all 0.3s;
            z-index: 100;
        }

        .toast.error {
            background: #e94560;
        }

        .toast.show {
            opacity: 1;
            transform: translateX(-50%) translateY(0);
        }

        /* Mobile */
        @media (max-width: 600px) {
            body {
                padding: 15px;
            }

            header h1 {
                font-size: 1.5rem;
            }

            .drop-zone {
                padding: 40px 20px;
            }

            .api-key-row {
                flex-direction: column;
            }

            .output-actions {
                width: 100%;
            }

            .action-btn {
                flex: 1;
                justify-content: center;
            }
        }
    </style>
</head>
<body>
    <div class="container">
        <header>
            <h1>üéôÔ∏è Podcast Transcriber</h1>
            <p>Transcribeer podcasts met AI (Nederlands, Engels, Spaans)</p>
        </header>

        <!-- API Key Section -->
        <div class="api-key-section">
            <label for="apiKey">OpenAI API Key <span style="color:#666">(voor lokale bestanden)</span></label>
            <div class="api-key-row">
                <input type="password" id="apiKey" class="api-key-input" placeholder="sk-...">
                <button class="save-btn" id="saveApiKey">Opslaan</button>
            </div>
            <div class="api-key-status" id="apiKeyStatus">
                <span>&#10003;</span> API key opgeslagen
            </div>
            <div class="api-key-hint">
                <a href="https://platform.openai.com/api-keys" target="_blank">OpenAI API keys</a>
            </div>
        </div>

        <div class="api-key-section" id="assemblyKeySection">
            <label for="assemblyKey">AssemblyAI API Key <span style="color:#666">(voor URLs - aanbevolen)</span></label>
            <div class="api-key-row">
                <input type="password" id="assemblyKey" class="api-key-input" placeholder="...">
                <button class="save-btn" id="saveAssemblyKey">Opslaan</button>
            </div>
            <div class="api-key-status" id="assemblyKeyStatus">
                <span>&#10003;</span> API key opgeslagen
            </div>
            <div class="api-key-hint">
                <a href="https://www.assemblyai.com/app/account" target="_blank">AssemblyAI API keys</a> - leest audio direct van URL (geen download nodig!)
            </div>
        </div>

        <!-- Drop Zone -->
        <div class="drop-zone" id="dropZone">
            <div class="drop-zone-icon">üéß</div>
            <div class="url-input-row">
                <input type="url" class="url-input" id="urlInput" placeholder="Plak podcast URL hier...">
                <button class="go-btn" id="goBtn">Start</button>
            </div>
            <div class="drop-zone-hint">Of drop een audio bestand</div>
            <button class="file-select-btn" id="fileSelectBtn">Kies bestand...</button>
        </div>
        <input type="file" class="file-input" id="fileInput" accept="audio/*">

        <!-- Options -->
        <div class="options">
            <label class="option-toggle" id="translateToggle">
                <div class="toggle-switch"></div>
                <span class="option-label">Vertaal naar Nederlands (als niet al NL)</span>
            </label>
        </div>

        <!-- Episode Info -->
        <div class="episode-info" id="episodeInfo">
            <div class="episode-title" id="episodeTitle"></div>
            <div class="episode-meta" id="episodeMeta"></div>
        </div>

        <!-- Status -->
        <div class="status" id="status">
            <div class="status-header">
                <div>
                    <div class="status-title" id="statusTitle">Bezig...</div>
                    <div class="status-subtitle" id="statusSubtitle"></div>
                </div>
                <button class="cancel-btn" id="cancelBtn">Annuleren</button>
            </div>
            <div class="progress-bar-container">
                <div class="progress-bar" id="progressBar"></div>
            </div>
            <div class="status-text" id="statusText"></div>
        </div>

        <!-- Output -->
        <div class="output" id="output">
            <div class="output-header">
                <div class="output-title">Transcriptie</div>
                <div class="output-actions">
                    <button class="action-btn" id="copyBtn">üìã Kopieer</button>
                    <button class="action-btn" id="downloadBtn">üíæ Download</button>
                    <a class="action-btn primary" id="speedreaderBtn" href="#" target="_blank">‚ö° Open in Speedreader</a>
                </div>
            </div>
            <div class="chapters" id="chapters">
                <div class="chapters-title">Hoofdstukken</div>
                <div id="chapterList"></div>
            </div>
            <div class="transcript-box" id="transcript"></div>
        </div>
    </div>

    <!-- Toast -->
    <div class="toast" id="toast"></div>

    <script>
        // Constants
        const CORS_PROXIES = [
            'https://api.allorigins.win/raw?url=',
            'https://corsproxy.io/?',
            'https://api.codetabs.com/v1/proxy?quest='
        ];
        const MAX_CHUNK_SIZE = 24 * 1024 * 1024; // 24MB to be safe (Whisper limit is 25MB)

        // State
        const state = {
            apiKey: '',
            assemblyKey: '',
            translateToNL: false,
            abortController: null,
            transcriptText: '',
            segments: [], // Transcript segments with timestamps
            chapters: []
        };

        // DOM elements
        const apiKeySection = document.querySelector('.api-key-section');
        const apiKeyInput = document.getElementById('apiKey');
        const saveApiKeyBtn = document.getElementById('saveApiKey');
        const assemblyKeySection = document.getElementById('assemblyKeySection');
        const assemblyKeyInput = document.getElementById('assemblyKey');
        const saveAssemblyKeyBtn = document.getElementById('saveAssemblyKey');
        const dropZone = document.getElementById('dropZone');
        const urlInput = document.getElementById('urlInput');
        const goBtn = document.getElementById('goBtn');
        const fileInput = document.getElementById('fileInput');
        const fileSelectBtn = document.getElementById('fileSelectBtn');
        const translateToggle = document.getElementById('translateToggle');
        const statusEl = document.getElementById('status');
        const statusTitle = document.getElementById('statusTitle');
        const statusSubtitle = document.getElementById('statusSubtitle');
        const statusText = document.getElementById('statusText');
        const progressBar = document.getElementById('progressBar');
        const cancelBtn = document.getElementById('cancelBtn');
        const outputEl = document.getElementById('output');
        const transcriptEl = document.getElementById('transcript');
        const chaptersEl = document.getElementById('chapters');
        const chapterListEl = document.getElementById('chapterList');
        const copyBtn = document.getElementById('copyBtn');
        const downloadBtn = document.getElementById('downloadBtn');
        const speedreaderBtn = document.getElementById('speedreaderBtn');
        const episodeInfo = document.getElementById('episodeInfo');
        const episodeTitle = document.getElementById('episodeTitle');
        const episodeMeta = document.getElementById('episodeMeta');
        const toast = document.getElementById('toast');

        // Initialize
        const init = () => {
            loadApiKey();
            setupEventListeners();
            checkUrlParam();
        };

        // Load API keys from localStorage
        const loadApiKey = () => {
            const savedKey = localStorage.getItem('transcriber_api_key');
            if (savedKey) {
                state.apiKey = savedKey;
                apiKeyInput.value = savedKey;
                apiKeySection.classList.add('has-key');
            }
            const savedAssemblyKey = localStorage.getItem('transcriber_assembly_key');
            if (savedAssemblyKey) {
                state.assemblyKey = savedAssemblyKey;
                assemblyKeyInput.value = savedAssemblyKey;
                assemblyKeySection.classList.add('has-key');
            }
        };

        // Save OpenAI API key to localStorage
        const saveApiKey = () => {
            const key = apiKeyInput.value.trim();
            if (key) {
                state.apiKey = key;
                localStorage.setItem('transcriber_api_key', key);
                apiKeySection.classList.add('has-key');
                saveApiKeyBtn.textContent = 'Opgeslagen!';
                saveApiKeyBtn.classList.add('saved');
                setTimeout(() => {
                    saveApiKeyBtn.textContent = 'Opslaan';
                    saveApiKeyBtn.classList.remove('saved');
                }, 2000);
            }
        };

        // Save AssemblyAI API key to localStorage
        const saveAssemblyKey = () => {
            const key = assemblyKeyInput.value.trim();
            if (key) {
                state.assemblyKey = key;
                localStorage.setItem('transcriber_assembly_key', key);
                assemblyKeySection.classList.add('has-key');
                saveAssemblyKeyBtn.textContent = 'Opgeslagen!';
                saveAssemblyKeyBtn.classList.add('saved');
                setTimeout(() => {
                    saveAssemblyKeyBtn.textContent = 'Opslaan';
                    saveAssemblyKeyBtn.classList.remove('saved');
                }, 2000);
            }
        };

        // Setup event listeners
        const setupEventListeners = () => {
            // OpenAI key
            saveApiKeyBtn.addEventListener('click', saveApiKey);
            apiKeyInput.addEventListener('keypress', (e) => {
                if (e.key === 'Enter') saveApiKey();
            });
            apiKeyInput.addEventListener('paste', (e) => {
                e.stopPropagation();
                setTimeout(saveApiKey, 50);
            });
            let saveTimeout;
            apiKeyInput.addEventListener('input', () => {
                clearTimeout(saveTimeout);
                saveTimeout = setTimeout(saveApiKey, 500);
            });

            // AssemblyAI key
            saveAssemblyKeyBtn.addEventListener('click', saveAssemblyKey);
            assemblyKeyInput.addEventListener('keypress', (e) => {
                if (e.key === 'Enter') saveAssemblyKey();
            });
            assemblyKeyInput.addEventListener('paste', (e) => {
                e.stopPropagation();
                setTimeout(saveAssemblyKey, 50);
            });
            let saveAssemblyTimeout;
            assemblyKeyInput.addEventListener('input', () => {
                clearTimeout(saveAssemblyTimeout);
                saveAssemblyTimeout = setTimeout(saveAssemblyKey, 500);
            });

            // URL input
            goBtn.addEventListener('click', handleUrlSubmit);
            urlInput.addEventListener('keypress', (e) => {
                if (e.key === 'Enter') handleUrlSubmit();
            });
            // Auto-submit when pasting into URL input
            urlInput.addEventListener('paste', () => {
                setTimeout(handleUrlSubmit, 100);
            });

            // Drop zone (drag/drop only)
            dropZone.addEventListener('dragover', handleDragOver);
            dropZone.addEventListener('dragleave', handleDragLeave);
            dropZone.addEventListener('drop', handleDrop);

            // File select button
            fileSelectBtn.addEventListener('click', (e) => {
                e.stopPropagation();
                fileInput.click();
            });

            // File input
            fileInput.addEventListener('change', handleFileSelect);

            // Global paste
            document.addEventListener('paste', handlePaste);

            // Toggle
            translateToggle.addEventListener('click', () => {
                state.translateToNL = !state.translateToNL;
                translateToggle.classList.toggle('active', state.translateToNL);
            });

            // Cancel button
            cancelBtn.addEventListener('click', cancelTranscription);

            // Copy button
            copyBtn.addEventListener('click', copyTranscript);

            // Download button
            downloadBtn.addEventListener('click', downloadTranscript);
        };

        // Handle URL submit from input field
        const handleUrlSubmit = () => {
            const url = urlInput.value.trim();
            if (url) {
                if (isValidUrl(url)) {
                    processUrl(url);
                    urlInput.value = '';
                } else {
                    showToast('Voer een geldige URL in', true);
                }
            }
        };

        // Handle file selection
        const handleFileSelect = (e) => {
            const file = e.target.files[0];
            if (file) {
                processAudioFile(file);
            }
            fileInput.value = ''; // Reset for next selection
        };

        // Handle drag over
        const handleDragOver = (e) => {
            e.preventDefault();
            dropZone.classList.add('drag-over');
        };

        // Handle drag leave
        const handleDragLeave = () => {
            dropZone.classList.remove('drag-over');
        };

        // Handle drop
        const handleDrop = (e) => {
            e.preventDefault();
            dropZone.classList.remove('drag-over');

            // Check for audio files first
            if (e.dataTransfer.files.length > 0) {
                const file = e.dataTransfer.files[0];
                if (file.type.startsWith('audio/') || /\.(mp3|m4a|wav|ogg|flac|webm)$/i.test(file.name)) {
                    processAudioFile(file);
                    return;
                }
            }

            // Otherwise check for URL
            const text = e.dataTransfer.getData('text/plain') || e.dataTransfer.getData('text/uri-list');
            if (text) {
                processUrl(text.trim());
            }
        };

        // Handle paste (for desktop - paste anywhere on page)
        const handlePaste = (e) => {
            // Ignore if pasting into input fields
            if (e.target === apiKeyInput || e.target === urlInput) return;

            const text = e.clipboardData.getData('text/plain');
            if (text && text.trim()) {
                const input = text.trim();
                if (isValidUrl(input)) {
                    e.preventDefault();
                    processUrl(input);
                }
                // Don't show error - user might be pasting something else
            }
        };

        // Check URL parameter
        const checkUrlParam = () => {
            const params = new URLSearchParams(window.location.search);
            const url = params.get('url');
            if (url) {
                processUrl(url);
            }
        };

        // Process local audio file
        const processAudioFile = async (file) => {
            // Check API key
            if (!state.apiKey) {
                showToast('Voer eerst je OpenAI API key in', true);
                apiKeyInput.focus();
                return;
            }

            // Reset output
            outputEl.classList.remove('show');
            episodeInfo.classList.remove('show');
            chaptersEl.classList.remove('show');

            try {
                state.abortController = new AbortController();
                const fileSizeMB = (file.size / (1024 * 1024)).toFixed(1);
                showStatus('Audio voorbereiden...', `${file.name} (${fileSizeMB} MB)`, 'indeterminate');

                // Convert to blob if needed
                const audioBlob = file;

                // Transcribe (handles chunking internally)
                await transcribeAndProcess(audioBlob, file.name);

            } catch (err) {
                if (err.name === 'AbortError') {
                    showToast('Geannuleerd');
                } else {
                    console.error('Error:', err);
                    showToast(err.message || 'Er ging iets mis', true);
                }
                hideStatus();
            }
        };

        // Process URL
        const processUrl = async (url) => {
            // Validate it's a URL
            if (!isValidUrl(url)) {
                showToast('Ongeldige URL', true);
                return;
            }

            // Check API keys - need at least one
            if (!state.apiKey && !state.assemblyKey) {
                showToast('Voer eerst een API key in', true);
                apiKeyInput.focus();
                return;
            }

            // Reset output
            outputEl.classList.remove('show');
            episodeInfo.classList.remove('show');
            chaptersEl.classList.remove('show');

            try {
                state.abortController = new AbortController();
                showStatus('URL analyseren...', '', 'indeterminate');

                // Determine if RSS or direct MP3
                let audioUrl = url;
                let episodeData = null;

                if (isRssUrl(url)) {
                    updateStatus('RSS feed ophalen...');
                    episodeData = await fetchLatestEpisode(url);
                    audioUrl = episodeData.audioUrl;
                    showEpisodeInfo(episodeData);
                } else if (!isAudioUrl(url)) {
                    // Try to fetch and check content type
                    updateStatus('Inhoud controleren...');
                    const content = await fetchWithCors(url);

                    if (content.includes('<rss') || content.includes('<feed')) {
                        // It's an RSS feed
                        episodeData = parseRssFeed(content);
                        audioUrl = episodeData.audioUrl;
                        showEpisodeInfo(episodeData);
                    } else if (content.includes('<html') || content.includes('<!DOCTYPE')) {
                        // It's an HTML page - try to extract audio URL
                        updateStatus('HTML pagina gevonden, zoeken naar audio...');
                        const extracted = extractAudioFromHtml(content, url);
                        if (extracted) {
                            audioUrl = extracted.audioUrl;
                            statusText.textContent = `Gevonden: ${audioUrl.substring(0, 60)}...`;
                            if (extracted.title) {
                                showEpisodeInfo({ title: extracted.title, pubDate: '' });
                            }
                        } else {
                            showToast('Geen audio gevonden op deze pagina', true);
                            hideStatus();
                            return;
                        }
                    } else {
                        showToast('URL is geen podcast feed of audio bestand', true);
                        hideStatus();
                        return;
                    }
                }

                // Use AssemblyAI if available (direct URL fetch - no download needed!)
                if (state.assemblyKey) {
                    updateStatus('Transcriberen via AssemblyAI...', 'Audio wordt direct van URL gelezen');
                    statusText.textContent = `URL: ${audioUrl.substring(0, 60)}...`;
                    await transcribeWithAssemblyAI(audioUrl);
                } else {
                    // Fall back to downloading + OpenAI Whisper
                    updateStatus('Audio downloaden...', getFilename(audioUrl));
                    const audioBlob = await downloadAudio(audioUrl);
                    await transcribeAndProcess(audioBlob, getFilename(audioUrl));
                }

            } catch (err) {
                if (err.name === 'AbortError') {
                    showToast('Geannuleerd');
                } else {
                    console.error('Error:', err);
                    showToast(err.message || 'Er ging iets mis', true);
                }
                hideStatus();
            }
        };

        // Main transcription and processing flow
        const transcribeAndProcess = async (audioBlob, filename) => {
            const fileSizeMB = (audioBlob.size / (1024 * 1024)).toFixed(1);

            // Check if we need to chunk
            if (audioBlob.size > MAX_CHUNK_SIZE) {
                updateStatus('Transcriberen...', `Groot bestand (${fileSizeMB} MB) - wordt in delen verwerkt`);
                state.segments = await transcribeInChunks(audioBlob);
            } else {
                updateStatus('Transcriberen...', `${fileSizeMB} MB`);
                setProgress(0);
                state.segments = await transcribeAudio(audioBlob);
            }

            // Build plain text from segments
            state.transcriptText = state.segments.map(s => s.text).join(' ');

            // Optionally translate
            if (state.translateToNL && !isLikelyDutch(state.transcriptText)) {
                updateStatus('Vertalen naar Nederlands...');
                state.transcriptText = await translateToNL(state.transcriptText);
                // Clear timestamps when translating (they won't match)
                state.segments = [{ start: 0, text: state.transcriptText }];
            }

            // Generate chapters
            updateStatus('Hoofdstukken detecteren...');
            state.chapters = await generateChapters(state.transcriptText);

            // Show result
            showResult();
            hideStatus();
        };

        // Transcribe using AssemblyAI (fetches audio directly from URL)
        const transcribeWithAssemblyAI = async (audioUrl) => {
            const debugLog = (msg) => {
                statusText.textContent = msg;
                console.log(msg);
            };

            // Step 1: Submit transcription job
            debugLog('Transcriptie job aanmaken...');
            const submitResponse = await fetch('https://api.assemblyai.com/v2/transcript', {
                method: 'POST',
                headers: {
                    'Authorization': state.assemblyKey,
                    'Content-Type': 'application/json'
                },
                body: JSON.stringify({
                    audio_url: audioUrl,
                    language_detection: true
                }),
                signal: state.abortController?.signal
            });

            if (!submitResponse.ok) {
                const err = await submitResponse.json().catch(() => ({}));
                throw new Error(err.error || `AssemblyAI fout: ${submitResponse.status}`);
            }

            const { id } = await submitResponse.json();
            debugLog(`Job gestart: ${id}`);

            // Step 2: Poll for completion
            let transcript = null;
            let pollCount = 0;
            const maxPolls = 300; // 5 minutes max (1 second intervals)

            while (pollCount < maxPolls) {
                await new Promise(r => setTimeout(r, 2000)); // Wait 2 seconds
                pollCount++;

                const pollResponse = await fetch(`https://api.assemblyai.com/v2/transcript/${id}`, {
                    headers: { 'Authorization': state.assemblyKey },
                    signal: state.abortController?.signal
                });

                if (!pollResponse.ok) {
                    throw new Error(`Polling fout: ${pollResponse.status}`);
                }

                transcript = await pollResponse.json();
                debugLog(`Status: ${transcript.status} (${pollCount * 2}s)`);

                if (transcript.status === 'completed') {
                    break;
                } else if (transcript.status === 'error') {
                    throw new Error(transcript.error || 'Transcriptie mislukt');
                }
                // 'queued' or 'processing' - continue polling
            }

            if (!transcript || transcript.status !== 'completed') {
                throw new Error('Transcriptie timeout');
            }

            // Step 3: Process result
            state.transcriptText = transcript.text || '';

            // Convert words to segments (group by ~30 seconds)
            if (transcript.words && transcript.words.length > 0) {
                state.segments = [];
                let currentSegment = { start: 0, text: '' };
                let segmentStart = transcript.words[0].start / 1000;

                for (const word of transcript.words) {
                    const wordTime = word.start / 1000;
                    if (wordTime - segmentStart > 30 && currentSegment.text) {
                        currentSegment.start = segmentStart;
                        state.segments.push(currentSegment);
                        currentSegment = { start: 0, text: '' };
                        segmentStart = wordTime;
                    }
                    currentSegment.text += (currentSegment.text ? ' ' : '') + word.text;
                }
                if (currentSegment.text) {
                    currentSegment.start = segmentStart;
                    state.segments.push(currentSegment);
                }
            } else {
                state.segments = [{ start: 0, text: state.transcriptText }];
            }

            // Optionally translate
            if (state.translateToNL && !isLikelyDutch(state.transcriptText)) {
                if (state.apiKey) {
                    updateStatus('Vertalen naar Nederlands...');
                    state.transcriptText = await translateToNL(state.transcriptText);
                    state.segments = [{ start: 0, text: state.transcriptText }];
                }
            }

            // Generate chapters (needs OpenAI key)
            if (state.apiKey) {
                updateStatus('Hoofdstukken detecteren...');
                state.chapters = await generateChapters(state.transcriptText);
            } else {
                state.chapters = [];
            }

            // Show result
            showResult();
            hideStatus();
        };

        // Validate URL
        const isValidUrl = (str) => {
            try {
                const url = new URL(str);
                return url.protocol === 'http:' || url.protocol === 'https:';
            } catch {
                return false;
            }
        };

        // Check if likely RSS URL
        const isRssUrl = (url) => {
            const lower = url.toLowerCase();
            return lower.includes('/feed') || lower.includes('/rss') ||
                   lower.includes('.xml') || lower.includes('feed=');
        };

        // Check if audio URL
        const isAudioUrl = (url) => {
            const lower = url.toLowerCase();
            return lower.includes('.mp3') || lower.includes('.m4a') ||
                   lower.includes('.wav') || lower.includes('.ogg') ||
                   lower.includes('audio');
        };

        // Extract audio URL from HTML page (for podcast players like Overcast, etc.)
        const extractAudioFromHtml = (html, pageUrl) => {
            const parser = new DOMParser();
            const doc = parser.parseFromString(html, 'text/html');

            let audioUrl = null;
            let title = null;

            // Try to get title
            const ogTitle = doc.querySelector('meta[property="og:title"]');
            const pageTitle = doc.querySelector('title');
            title = ogTitle?.content || pageTitle?.textContent || null;

            // Method 1: Look for og:audio meta tag
            const ogAudio = doc.querySelector('meta[property="og:audio"]');
            if (ogAudio?.content) {
                audioUrl = ogAudio.content;
            }

            // Method 2: Look for <audio> element with source
            if (!audioUrl) {
                const audioEl = doc.querySelector('audio');
                if (audioEl) {
                    const source = audioEl.querySelector('source[src]');
                    audioUrl = source?.src || audioEl.src;
                }
            }

            // Method 3: Look for direct audio links in the HTML
            if (!audioUrl) {
                const audioPatterns = [
                    /["'](https?:\/\/[^"']+\.mp3[^"']*)/gi,
                    /["'](https?:\/\/[^"']+\.m4a[^"']*)/gi,
                    /["'](https?:\/\/[^"']+\/audio\/[^"']+)/gi,
                    /data-url=["']([^"']+\.mp3[^"']*)/gi
                ];

                for (const pattern of audioPatterns) {
                    const matches = html.matchAll(pattern);
                    for (const match of matches) {
                        // Skip tracking/analytics URLs
                        if (!match[1].includes('tracking') && !match[1].includes('analytics')) {
                            audioUrl = match[1];
                            break;
                        }
                    }
                    if (audioUrl) break;
                }
            }

            // Method 4: Overcast-specific - look for audio source in script
            if (!audioUrl && pageUrl.includes('overcast.fm')) {
                const sourceMatch = html.match(/source\s+src=["']([^"']+)/);
                if (sourceMatch) {
                    audioUrl = sourceMatch[1];
                }
            }

            if (audioUrl) {
                // Make relative URLs absolute
                if (audioUrl.startsWith('/')) {
                    const base = new URL(pageUrl);
                    audioUrl = base.origin + audioUrl;
                }
                return { audioUrl, title };
            }

            return null;
        };

        // Get filename from URL
        const getFilename = (url) => {
            try {
                const pathname = new URL(url).pathname;
                const parts = pathname.split('/');
                return parts[parts.length - 1] || 'audio';
            } catch {
                return 'audio';
            }
        };

        // Fetch with CORS proxy
        const fetchWithCors = async (url) => {
            for (const proxy of CORS_PROXIES) {
                try {
                    const response = await fetch(proxy + encodeURIComponent(url), {
                        signal: state.abortController?.signal
                    });
                    if (response.ok) {
                        return await response.text();
                    }
                } catch (e) {
                    console.log('Proxy failed for text:', proxy, e.message);
                }
            }
            throw new Error('Kon URL niet ophalen');
        };

        // Fetch latest episode from RSS feed
        const fetchLatestEpisode = async (feedUrl) => {
            const content = await fetchWithCors(feedUrl);
            return parseRssFeed(content);
        };

        // Parse RSS feed and get latest episode
        const parseRssFeed = (xml) => {
            const parser = new DOMParser();
            const doc = parser.parseFromString(xml, 'text/xml');

            // Find first item/entry with audio enclosure
            const items = doc.querySelectorAll('item, entry');

            for (const item of items) {
                // Try enclosure tag (RSS 2.0)
                const enclosure = item.querySelector('enclosure[type^="audio"], enclosure[url*=".mp3"], enclosure[url*=".m4a"]');
                if (enclosure) {
                    return {
                        title: item.querySelector('title')?.textContent || 'Onbekende aflevering',
                        pubDate: item.querySelector('pubDate')?.textContent || '',
                        audioUrl: enclosure.getAttribute('url')
                    };
                }

                // Try media:content tag
                const mediaContent = item.querySelector('content[type^="audio"], content[url*=".mp3"]');
                if (mediaContent) {
                    return {
                        title: item.querySelector('title')?.textContent || 'Onbekende aflevering',
                        pubDate: item.querySelector('pubDate, published')?.textContent || '',
                        audioUrl: mediaContent.getAttribute('url')
                    };
                }

                // Try link ending in audio extension
                const links = item.querySelectorAll('link');
                for (const link of links) {
                    const href = link.getAttribute('href') || link.textContent;
                    if (href && (href.includes('.mp3') || href.includes('.m4a'))) {
                        return {
                            title: item.querySelector('title')?.textContent || 'Onbekende aflevering',
                            pubDate: item.querySelector('pubDate, published')?.textContent || '',
                            audioUrl: href
                        };
                    }
                }
            }

            throw new Error('Geen audio gevonden in feed');
        };

        // Show episode info
        const showEpisodeInfo = (data) => {
            episodeTitle.textContent = data.title;
            episodeMeta.textContent = data.pubDate ? `Gepubliceerd: ${formatDate(data.pubDate)}` : '';
            episodeInfo.classList.add('show');
        };

        // Format date
        const formatDate = (dateStr) => {
            try {
                const date = new Date(dateStr);
                return date.toLocaleDateString('nl-NL', {
                    year: 'numeric',
                    month: 'long',
                    day: 'numeric'
                });
            } catch {
                return dateStr;
            }
        };

        // Download audio file
        const downloadAudio = async (url) => {
            const debugLog = (msg) => {
                statusText.textContent = msg;
                console.log(msg);
            };

            debugLog(`Audio URL: ${url.substring(0, 80)}...`);

            // Try direct fetch first
            try {
                debugLog('Poging 1: Direct fetch...');
                const response = await fetch(url, {
                    signal: state.abortController?.signal
                });
                debugLog(`Direct: status ${response.status}`);
                if (response.ok) {
                    const blob = await response.blob();
                    debugLog(`Direct OK: ${(blob.size / 1024).toFixed(0)} KB`);
                    if (blob.size > 1000) {
                        return blob;
                    }
                    debugLog(`Direct: te klein (${blob.size} bytes)`);
                }
            } catch (e) {
                debugLog(`Direct mislukt: ${e.message}`);
            }

            // Try CORS proxies
            for (let i = 0; i < CORS_PROXIES.length; i++) {
                const proxy = CORS_PROXIES[i];
                try {
                    debugLog(`Poging ${i + 2}: Proxy ${i + 1}...`);
                    const proxyUrl = proxy + encodeURIComponent(url);
                    const response = await fetch(proxyUrl, {
                        signal: state.abortController?.signal
                    });
                    debugLog(`Proxy ${i + 1}: status ${response.status}`);
                    if (response.ok) {
                        const blob = await response.blob();
                        debugLog(`Proxy ${i + 1}: ${(blob.size / 1024).toFixed(0)} KB`);
                        if (blob.size > 1000) {
                            return blob;
                        }
                        debugLog(`Proxy ${i + 1}: te klein (${blob.size} bytes)`);
                    }
                } catch (e) {
                    debugLog(`Proxy ${i + 1} mislukt: ${e.message}`);
                }
            }

            throw new Error(`Download mislukt. URL: ${url.substring(0, 60)}...`);
        };

        // Transcribe audio using OpenAI Whisper (returns segments with timestamps)
        const transcribeAudio = async (audioBlob, timeOffset = 0) => {
            const formData = new FormData();
            formData.append('file', audioBlob, 'audio.mp3');
            formData.append('model', 'whisper-1');
            formData.append('response_format', 'verbose_json');

            const response = await fetch('https://api.openai.com/v1/audio/transcriptions', {
                method: 'POST',
                headers: {
                    'Authorization': `Bearer ${state.apiKey}`
                },
                body: formData,
                signal: state.abortController?.signal
            });

            if (!response.ok) {
                const error = await response.json().catch(() => ({}));
                if (response.status === 401) {
                    throw new Error('Ongeldige API key');
                }
                throw new Error(error.error?.message || 'Transcriptie mislukt');
            }

            const data = await response.json();

            // Convert to our segment format with time offset applied
            return (data.segments || []).map(seg => ({
                start: seg.start + timeOffset,
                end: seg.end + timeOffset,
                text: seg.text.trim()
            }));
        };

        // Transcribe large audio in chunks
        const transcribeInChunks = async (audioBlob) => {
            // For simplicity, we'll split by size
            // In a real implementation, you'd want to split at silence points
            const chunks = [];
            const chunkSize = MAX_CHUNK_SIZE;
            let offset = 0;

            while (offset < audioBlob.size) {
                const chunk = audioBlob.slice(offset, offset + chunkSize);
                chunks.push(chunk);
                offset += chunkSize;
            }

            const allSegments = [];
            let timeOffset = 0;

            for (let i = 0; i < chunks.length; i++) {
                const progress = Math.round(((i + 1) / chunks.length) * 100);
                updateStatus(`Transcriberen...`, `Deel ${i + 1} van ${chunks.length}`);
                setProgress(progress);

                const chunkSegments = await transcribeAudio(chunks[i], timeOffset);
                allSegments.push(...chunkSegments);

                // Estimate time offset for next chunk based on last segment
                if (chunkSegments.length > 0) {
                    timeOffset = chunkSegments[chunkSegments.length - 1].end;
                }
            }

            return allSegments;
        };

        // Generate chapters using GPT
        const generateChapters = async (text) => {
            // Skip for very short transcripts
            if (text.length < 500) return [];

            try {
                const response = await fetch('https://api.openai.com/v1/chat/completions', {
                    method: 'POST',
                    headers: {
                        'Authorization': `Bearer ${state.apiKey}`,
                        'Content-Type': 'application/json'
                    },
                    body: JSON.stringify({
                        model: 'gpt-4o-mini',
                        messages: [
                            {
                                role: 'system',
                                content: `Analyseer deze podcast transcriptie en identificeer 3-7 hoofdstukken/onderwerpen.
Geef voor elk hoofdstuk een korte titel (max 5 woorden).
Antwoord ALLEEN in JSON formaat: [{"title": "Titel hier"}, ...]
Geen uitleg, alleen de JSON array.`
                            },
                            {
                                role: 'user',
                                content: text.substring(0, 8000) // Limit input
                            }
                        ],
                        temperature: 0.3
                    }),
                    signal: state.abortController?.signal
                });

                if (!response.ok) return [];

                const data = await response.json();
                const content = data.choices[0]?.message?.content || '[]';

                // Parse JSON from response
                const jsonMatch = content.match(/\[[\s\S]*\]/);
                if (jsonMatch) {
                    return JSON.parse(jsonMatch[0]);
                }
            } catch (e) {
                console.error('Chapter generation failed:', e);
            }
            return [];
        };

        // Translate to Dutch using OpenAI
        const translateToNL = async (text) => {
            const response = await fetch('https://api.openai.com/v1/chat/completions', {
                method: 'POST',
                headers: {
                    'Authorization': `Bearer ${state.apiKey}`,
                    'Content-Type': 'application/json'
                },
                body: JSON.stringify({
                    model: 'gpt-4o-mini',
                    messages: [
                        {
                            role: 'system',
                            content: 'Je bent een vertaler. Vertaal de volgende tekst naar Nederlands. Behoud de oorspronkelijke opmaak en alinea\'s. Geef alleen de vertaling terug, geen uitleg.'
                        },
                        {
                            role: 'user',
                            content: text
                        }
                    ],
                    temperature: 0.3
                }),
                signal: state.abortController?.signal
            });

            if (!response.ok) {
                const error = await response.json().catch(() => ({}));
                throw new Error(error.error?.message || 'Vertaling mislukt');
            }

            const data = await response.json();
            return data.choices[0]?.message?.content || text;
        };

        // Simple check if text is likely Dutch
        const isLikelyDutch = (text) => {
            const dutchWords = ['de', 'het', 'een', 'van', 'en', 'in', 'dat', 'op', 'te', 'voor', 'met', 'zijn', 'er', 'aan', 'om', 'ook', 'als', 'maar', 'bij', 'dan', 'nog', 'wel', 'geen', 'meer', 'al', 'nu'];
            const words = text.toLowerCase().split(/\s+/).slice(0, 200);
            const matches = words.filter(w => dutchWords.includes(w)).length;
            return matches / words.length > 0.1;
        };

        // Show status
        const showStatus = (title, subtitle = '', progressType = 'indeterminate') => {
            statusTitle.textContent = title;
            statusSubtitle.textContent = subtitle;
            statusText.textContent = '';
            progressBar.className = 'progress-bar ' + progressType;
            if (progressType === 'indeterminate') {
                progressBar.style.width = '30%';
            }
            statusEl.classList.add('show');
        };

        // Update status
        const updateStatus = (title, subtitle = '') => {
            statusTitle.textContent = title;
            if (subtitle) statusSubtitle.textContent = subtitle;
        };

        // Set progress
        const setProgress = (percent) => {
            progressBar.className = 'progress-bar';
            progressBar.style.width = percent + '%';
        };

        // Hide status
        const hideStatus = () => {
            statusEl.classList.remove('show');
            state.abortController = null;
        };

        // Cancel transcription
        const cancelTranscription = () => {
            if (state.abortController) {
                state.abortController.abort();
            }
        };

        // Format time as MM:SS
        const formatTime = (seconds) => {
            const mins = Math.floor(seconds / 60);
            const secs = Math.floor(seconds % 60);
            return `${mins}:${secs.toString().padStart(2, '0')}`;
        };

        // Show result
        const showResult = () => {
            // Display transcript with timestamps
            if (state.segments.length > 0 && state.segments[0].start !== undefined) {
                // Group segments into paragraphs (every ~30 seconds or by sentence)
                let html = '';
                let currentParagraph = [];
                let paragraphStart = 0;

                for (const seg of state.segments) {
                    if (currentParagraph.length === 0) {
                        paragraphStart = seg.start;
                    }
                    currentParagraph.push(seg.text);

                    // Start new paragraph after ~30 seconds or sentence-ending punctuation
                    const timeDiff = seg.end - paragraphStart;
                    const endsWithSentence = /[.!?]$/.test(seg.text);

                    if (timeDiff > 30 && endsWithSentence) {
                        html += `<div class="segment">
                            <span class="segment-time">${formatTime(paragraphStart)}</span>
                            <span class="segment-text">${currentParagraph.join(' ')}</span>
                        </div>`;
                        currentParagraph = [];
                    }
                }

                // Add remaining text
                if (currentParagraph.length > 0) {
                    html += `<div class="segment">
                        <span class="segment-time">${formatTime(paragraphStart)}</span>
                        <span class="segment-text">${currentParagraph.join(' ')}</span>
                    </div>`;
                }

                transcriptEl.innerHTML = html;
            } else {
                // Plain text without timestamps
                transcriptEl.textContent = state.transcriptText;
            }

            // Display chapters
            if (state.chapters.length > 0) {
                chapterListEl.innerHTML = state.chapters.map((ch, i) => `
                    <div class="chapter-item">
                        <span class="chapter-time">${i + 1}.</span>
                        <span class="chapter-name">${ch.title}</span>
                    </div>
                `).join('');
                chaptersEl.classList.add('show');
            } else {
                chaptersEl.classList.remove('show');
            }

            // Update speedreader link
            const speedreaderUrl = new URL('/speedreader/', window.location.origin);
            speedreaderUrl.searchParams.set('text', state.transcriptText.substring(0, 10000));
            speedreaderBtn.href = speedreaderUrl.toString();

            outputEl.classList.add('show');
        };

        // Download transcript as text file
        const downloadTranscript = () => {
            // Build content with timestamps
            let content = '';
            if (state.chapters.length > 0) {
                content += 'HOOFDSTUKKEN\n';
                content += state.chapters.map((ch, i) => `${i + 1}. ${ch.title}`).join('\n');
                content += '\n\n---\n\n';
            }

            if (state.segments.length > 0 && state.segments[0].start !== undefined) {
                for (const seg of state.segments) {
                    content += `[${formatTime(seg.start)}] ${seg.text}\n`;
                }
            } else {
                content = state.transcriptText;
            }

            const blob = new Blob([content], { type: 'text/plain;charset=utf-8' });
            const url = URL.createObjectURL(blob);
            const a = document.createElement('a');
            a.href = url;
            a.download = 'transcriptie.txt';
            a.click();
            URL.revokeObjectURL(url);
        };

        // Copy transcript
        const copyTranscript = async () => {
            try {
                await navigator.clipboard.writeText(state.transcriptText);
                showToast('Gekopieerd naar klembord');
            } catch (err) {
                showToast('Kopi√´ren mislukt', true);
            }
        };

        // Show toast
        const showToast = (message, isError = false) => {
            toast.textContent = message;
            toast.className = 'toast' + (isError ? ' error' : '');
            toast.classList.add('show');
            setTimeout(() => toast.classList.remove('show'), 3000);
        };

        // Initialize
        init();
    </script>
</body>
</html>
