<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <meta name="apple-mobile-web-app-capable" content="yes">
    <meta name="apple-mobile-web-app-status-bar-style" content="black">
    <title>Speedreader</title>
    <link rel="icon" type="image/svg+xml" href="data:image/svg+xml,<svg xmlns='http://www.w3.org/2000/svg' viewBox='0 0 32 32'><rect fill='%23000' width='32' height='32'/><text x='16' y='22' text-anchor='middle' fill='%23fff' font-size='18' font-family='system-ui'>â–¶</text></svg>">
    <link rel="apple-touch-icon" href="apple-touch-icon.png">
    <script src="https://cdn.jsdelivr.net/npm/@mozilla/readability@0.5.0/Readability.min.js"></script>
    <style>
        * {
            box-sizing: border-box;
            margin: 0;
            padding: 0;
        }

        body {
            font-family: -apple-system, BlinkMacSystemFont, 'Segoe UI', Roboto, sans-serif;
            background: #000;
            color: #fff;
            min-height: 100vh;
            overflow: hidden;
            user-select: none;
        }

        /* Main reading display */
        .reader-container {
            position: fixed;
            inset: 0;
            display: flex;
            align-items: center;
            justify-content: center;
        }

        .word-display {
            font-size: clamp(2rem, 8vw, 5rem);
            font-weight: 600;
            letter-spacing: 0.05em;
            white-space: nowrap;
            position: relative;
            max-width: 90vw;
            transition: font-size 0.1s ease;
        }

        .word-display .letter {
            display: inline-block;
        }

        .word-display .focus-letter {
            color: #e94560;
        }

        /* Focus marker */
        .focus-marker {
            position: fixed;
            left: 50%;
            transform: translateX(-50%);
            color: #e94560;
            font-size: 1.5rem;
            opacity: 0.6;
        }

        .focus-marker.top {
            top: calc(50% - 4rem);
        }

        .focus-marker.bottom {
            top: calc(50% + 3rem);
        }

        /* Bottom controls container */
        .bottom-controls {
            position: fixed;
            bottom: 30px;
            left: 50%;
            transform: translateX(-50%);
            display: flex;
            flex-direction: column;
            align-items: center;
            gap: 20px;
            z-index: 100;
        }

        /* Speed controls - bottom, horizontal */
        .speed-controls {
            display: flex;
            flex-direction: row;
            gap: 8px;
        }

        .speed-btn {
            background: rgba(255, 255, 255, 0.1);
            border: 1px solid rgba(255, 255, 255, 0.2);
            color: #fff;
            padding: 10px 16px;
            border-radius: 8px;
            cursor: pointer;
            font-size: 0.85rem;
            font-weight: 500;
            transition: all 0.2s;
            min-width: 50px;
            text-align: center;
        }

        .speed-btn:hover {
            background: rgba(255, 255, 255, 0.2);
        }

        .speed-btn.active {
            background: #e94560;
            border-color: #e94560;
        }

        /* Play/Pause button */
        .play-pause-container {
        }

        .play-pause-btn {
            background: #e94560;
            border: none;
            color: #fff;
            padding: 16px 48px;
            border-radius: 50px;
            cursor: pointer;
            font-size: 1.1rem;
            font-weight: 600;
            transition: all 0.2s;
            display: flex;
            align-items: center;
            gap: 10px;
        }

        .play-pause-btn:hover {
            background: #ff6b6b;
            transform: scale(1.05);
        }

        .play-pause-btn svg {
            width: 24px;
            height: 24px;
        }

        /* Progress bar */
        .progress-container {
            position: fixed;
            bottom: 0;
            left: 0;
            right: 0;
            height: 4px;
            background: rgba(255, 255, 255, 0.1);
        }

        .progress-bar {
            height: 100%;
            background: #e94560;
            width: 0%;
            transition: width 0.1s linear;
        }

        /* Input overlay */
        .input-overlay {
            position: fixed;
            inset: 0;
            background: rgba(0, 0, 0, 0.95);
            display: flex;
            align-items: center;
            justify-content: center;
            z-index: 200;
        }

        .input-overlay.hidden {
            display: none;
        }

        .input-box {
            max-width: 600px;
            width: 90%;
            text-align: center;
        }

        .input-box h2 {
            font-size: 1.8rem;
            margin-bottom: 20px;
            color: #fff;
        }

        .input-box p {
            color: #888;
            margin-bottom: 30px;
            line-height: 1.6;
        }

        .drop-zone {
            border: 2px dashed rgba(255, 255, 255, 0.3);
            border-radius: 16px;
            padding: 60px 40px;
            cursor: pointer;
            transition: all 0.3s;
            background: rgba(255, 255, 255, 0.02);
        }

        .drop-zone:hover,
        .drop-zone.drag-over {
            border-color: #e94560;
            background: rgba(233, 69, 96, 0.1);
        }

        .drop-zone-icon {
            font-size: 3rem;
            margin-bottom: 20px;
        }

        .drop-zone-text {
            font-size: 1.1rem;
            color: #aaa;
        }

        .drop-zone-hint {
            font-size: 0.9rem;
            color: #666;
            margin-top: 15px;
        }

        /* Resume banner */
        .resume-banner {
            position: fixed;
            top: 20px;
            left: 50%;
            transform: translateX(-50%);
            background: rgba(233, 69, 96, 0.9);
            padding: 12px 24px;
            border-radius: 8px;
            display: flex;
            align-items: center;
            gap: 15px;
            z-index: 150;
        }

        .resume-banner.hidden {
            display: none;
        }

        .resume-banner button {
            background: #fff;
            color: #e94560;
            border: none;
            padding: 8px 16px;
            border-radius: 6px;
            cursor: pointer;
            font-weight: 600;
            font-size: 0.9rem;
        }

        .resume-banner .dismiss {
            background: transparent;
            color: #fff;
            padding: 8px;
        }

        /* Word count display */
        .word-count {
            position: fixed;
            top: 20px;
            left: 20px;
            color: #666;
            font-size: 0.9rem;
            z-index: 100;
        }

        /* Timer display */
        .timer-display {
            position: fixed;
            bottom: 20px;
            right: 20px;
            color: #555;
            font-size: 0.85rem;
            z-index: 100;
            font-variant-numeric: tabular-nums;
        }

        /* Debug button */
        .debug-btn {
            position: fixed;
            top: 60px;
            left: 20px;
            width: 30px;
            height: 30px;
            background: transparent;
            border: none;
            cursor: pointer;
            opacity: 0;
            z-index: 150;
        }

        .debug-btn:hover {
            opacity: 0.3;
            background: #555;
        }

        /* Debug overlay */
        .debug-overlay {
            position: fixed;
            inset: 0;
            background: rgba(0, 0, 0, 0.95);
            z-index: 400;
            overflow-y: auto;
            padding: 20px;
            display: none;
        }

        .debug-overlay.show {
            display: block;
        }

        .debug-overlay .close-btn {
            position: fixed;
            top: 20px;
            right: 20px;
            background: #e94560;
            border: none;
            color: #fff;
            padding: 8px 16px;
            border-radius: 6px;
            cursor: pointer;
            font-size: 0.9rem;
        }

        .debug-overlay .word-list {
            max-width: 600px;
            margin: 0 auto;
            padding-top: 60px;
        }

        .debug-overlay .word-item {
            padding: 4px 8px;
            border-bottom: 1px solid #333;
            font-family: monospace;
            font-size: 0.9rem;
            color: #aaa;
        }

        .debug-overlay .word-item span {
            color: #666;
            margin-right: 10px;
        }

        /* Loading state */
        .loading {
            display: flex;
            flex-direction: column;
            align-items: center;
            gap: 20px;
        }

        .spinner {
            width: 40px;
            height: 40px;
            border: 3px solid rgba(255, 255, 255, 0.2);
            border-top-color: #e94560;
            border-radius: 50%;
            animation: spin 0.8s linear infinite;
        }

        @keyframes spin {
            to { transform: rotate(360deg); }
        }

        /* Toast notification */
        .toast {
            position: fixed;
            bottom: 100px;
            left: 50%;
            transform: translateX(-50%) translateY(50px);
            background: #333;
            color: #fff;
            padding: 12px 24px;
            border-radius: 8px;
            opacity: 0;
            transition: all 0.3s;
            z-index: 300;
        }

        .toast.error {
            background: #e94560;
        }

        .toast.show {
            opacity: 1;
            transform: translateX(-50%) translateY(0);
        }

        /* Mobile adjustments */
        @media (max-width: 600px) {
            .bottom-controls {
                bottom: 20px;
                gap: 15px;
            }

            .speed-controls {
                gap: 4px;
            }

            .speed-btn {
                padding: 8px 10px;
                font-size: 0.75rem;
                min-width: 40px;
            }

            .play-pause-btn {
                padding: 12px 28px;
                font-size: 0.95rem;
            }

            .word-count {
                font-size: 0.8rem;
            }
        }
    </style>
</head>
<body>
    <!-- Focus markers -->
    <div class="focus-marker top">â–¼</div>
    <div class="focus-marker bottom">â–²</div>

    <!-- Main reading display -->
    <div class="reader-container">
        <div class="word-display" id="wordDisplay"></div>
    </div>

    <!-- Word count -->
    <div class="word-count" id="wordCount"></div>

    <!-- Timer display -->
    <div class="timer-display" id="timerDisplay"></div>

    <!-- Bottom controls -->
    <div class="bottom-controls">
        <!-- Speed controls -->
        <div class="speed-controls" id="speedControls">
            <button class="speed-btn" data-speed="300">300</button>
            <button class="speed-btn" data-speed="450">450</button>
            <button class="speed-btn active" data-speed="600">600</button>
            <button class="speed-btn" data-speed="750">750</button>
            <button class="speed-btn" data-speed="900">900</button>
        </div>

        <!-- Play/Pause button -->
        <div class="play-pause-container">
            <button class="play-pause-btn" id="playPauseBtn">
                <svg id="playIcon" fill="currentColor" viewBox="0 0 24 24">
                    <path d="M8 5v14l11-7z"/>
                </svg>
                <svg id="pauseIcon" fill="currentColor" viewBox="0 0 24 24" style="display:none;">
                    <path d="M6 19h4V5H6v14zm8-14v14h4V5h-4z"/>
                </svg>
                <span id="playPauseText">Start</span>
            </button>
        </div>
    </div>

    <!-- Progress bar -->
    <div class="progress-container">
        <div class="progress-bar" id="progressBar"></div>
    </div>

    <!-- Input overlay -->
    <div class="input-overlay" id="inputOverlay">
        <div class="input-box">
            <h2>Speedreader</h2>
            <p>Read faster by focusing on one word at a time</p>
            <div class="drop-zone" id="dropZone">
                <div class="drop-zone-icon">ðŸ“–</div>
                <div class="drop-zone-text">Drop text or URL here, or click to paste</div>
                <div class="drop-zone-hint">Supports: text, URLs to articles, text files</div>
            </div>
        </div>
    </div>

    <!-- Resume banner -->
    <div class="resume-banner hidden" id="resumeBanner">
        <span>You have a saved reading session</span>
        <button id="resumeBtn">Resume</button>
        <button class="dismiss" id="dismissBtn">âœ•</button>
    </div>

    <!-- Toast -->
    <div class="toast" id="toast"></div>

    <!-- Debug button (invisible) -->
    <button class="debug-btn" id="debugBtn"></button>

    <!-- Debug overlay -->
    <div class="debug-overlay" id="debugOverlay">
        <button class="close-btn" id="debugCloseBtn">Sluiten</button>
        <div class="word-list" id="debugWordList"></div>
    </div>

    <script>
        // State
        const state = {
            words: [],
            currentIndex: 0,
            isPlaying: false,
            speed: 600, // WPM
            timeoutId: null,
            textLoaded: false,
            // Timer state
            timerStartTime: null,
            timerElapsed: 0,
            timerIntervalId: null,
            wordsRead: 0
        };

        // DOM elements
        const wordDisplay = document.getElementById('wordDisplay');
        const inputOverlay = document.getElementById('inputOverlay');
        const dropZone = document.getElementById('dropZone');
        const playPauseBtn = document.getElementById('playPauseBtn');
        const playIcon = document.getElementById('playIcon');
        const pauseIcon = document.getElementById('pauseIcon');
        const playPauseText = document.getElementById('playPauseText');
        const progressBar = document.getElementById('progressBar');
        const wordCountDisplay = document.getElementById('wordCount');
        const resumeBanner = document.getElementById('resumeBanner');
        const toast = document.getElementById('toast');
        const speedControls = document.getElementById('speedControls');
        const timerDisplay = document.getElementById('timerDisplay');
        const debugBtn = document.getElementById('debugBtn');
        const debugOverlay = document.getElementById('debugOverlay');
        const debugWordList = document.getElementById('debugWordList');
        const debugCloseBtn = document.getElementById('debugCloseBtn');

        // CORS proxy for fetching URLs
        const CORS_PROXY = 'https://api.allorigins.win/raw?url=';

        // Initialize
        const init = () => {
            loadSettings();
            setupEventListeners();
            checkUrlParam();
            checkSavedSession();
        };

        // Load settings from localStorage
        const loadSettings = () => {
            const savedSpeed = localStorage.getItem('speedreader_speed');
            if (savedSpeed) {
                state.speed = parseInt(savedSpeed, 10);
                updateSpeedButtons();
            }
        };

        // Save settings to localStorage
        const saveSettings = () => {
            localStorage.setItem('speedreader_speed', state.speed.toString());
        };

        // Save reading session
        const saveSession = () => {
            if (state.words.length > 0) {
                const session = {
                    words: state.words,
                    currentIndex: state.currentIndex,
                    timestamp: Date.now()
                };
                localStorage.setItem('speedreader_session', JSON.stringify(session));
            }
        };

        // Load saved session
        const loadSession = () => {
            const saved = localStorage.getItem('speedreader_session');
            if (saved) {
                try {
                    const session = JSON.parse(saved);
                    // Only restore if less than 24 hours old
                    if (Date.now() - session.timestamp < 24 * 60 * 60 * 1000) {
                        return session;
                    }
                } catch (e) {
                    console.error('Failed to parse saved session:', e);
                }
            }
            return null;
        };

        // Clear saved session
        const clearSession = () => {
            localStorage.removeItem('speedreader_session');
        };

        // Check for saved session on load
        const checkSavedSession = () => {
            const session = loadSession();
            if (session && session.words.length > 0 && session.currentIndex < session.words.length) {
                resumeBanner.classList.remove('hidden');
            }
        };

        // Setup event listeners
        const setupEventListeners = () => {
            // Drop zone events
            dropZone.addEventListener('click', handleDropZoneClick);
            dropZone.addEventListener('dragover', handleDragOver);
            dropZone.addEventListener('dragleave', handleDragLeave);
            dropZone.addEventListener('drop', handleDrop);

            // Global paste event
            document.addEventListener('paste', handlePaste);

            // Play/pause button
            playPauseBtn.addEventListener('click', togglePlayPause);

            // Speed buttons
            speedControls.querySelectorAll('.speed-btn').forEach(btn => {
                btn.addEventListener('click', () => {
                    state.speed = parseInt(btn.dataset.speed, 10);
                    updateSpeedButtons();
                    saveSettings();
                });
            });

            // Resume banner
            document.getElementById('resumeBtn').addEventListener('click', () => {
                const session = loadSession();
                if (session) {
                    state.words = session.words;
                    state.currentIndex = session.currentIndex;
                    state.textLoaded = true;
                    inputOverlay.classList.add('hidden');
                    resumeBanner.classList.add('hidden');
                    updateWordCount();
                    displayWord();
                }
            });

            document.getElementById('dismissBtn').addEventListener('click', () => {
                resumeBanner.classList.add('hidden');
                clearSession();
            });

            // Keyboard controls
            document.addEventListener('keydown', handleKeydown);

            // Click on reader to toggle play/pause
            document.querySelector('.reader-container').addEventListener('click', (e) => {
                if (state.textLoaded && e.target.closest('.reader-container')) {
                    togglePlayPause();
                }
            });

            // Debug button
            debugBtn.addEventListener('click', showDebugOverlay);
            debugCloseBtn.addEventListener('click', hideDebugOverlay);
        };

        // Show debug overlay with word list
        const showDebugOverlay = () => {
            if (state.words.length === 0) {
                showToast('Geen woorden geladen', true);
                return;
            }

            let html = '';
            state.words.forEach((word, index) => {
                const isCurrent = index === state.currentIndex;
                const style = isCurrent ? 'color: #e94560; font-weight: bold;' : '';
                html += `<div class="word-item" style="${style}"><span>${index + 1}</span>${escapeHtml(word)}</div>`;
            });
            debugWordList.innerHTML = html;
            debugOverlay.classList.add('show');
        };

        // Hide debug overlay
        const hideDebugOverlay = () => {
            debugOverlay.classList.remove('show');
        };

        // Handle keyboard shortcuts
        const handleKeydown = (e) => {
            if (!state.textLoaded) return;

            switch (e.code) {
                case 'Space':
                    e.preventDefault();
                    togglePlayPause();
                    break;
                case 'ArrowLeft':
                    e.preventDefault();
                    skipWords(-10);
                    break;
                case 'ArrowRight':
                    e.preventDefault();
                    skipWords(10);
                    break;
                case 'ArrowUp':
                    e.preventDefault();
                    changeSpeed(150);
                    break;
                case 'ArrowDown':
                    e.preventDefault();
                    changeSpeed(-150);
                    break;
                case 'Escape':
                    e.preventDefault();
                    resetReader();
                    break;
            }
        };

        // Skip words forward/backward
        const skipWords = (count) => {
            state.currentIndex = Math.max(0, Math.min(state.words.length - 1, state.currentIndex + count));
            saveSession();
            displayWord();
            updateProgress();
        };

        // Change speed
        const changeSpeed = (delta) => {
            const speeds = [300, 450, 600, 750, 900];
            const currentIdx = speeds.indexOf(state.speed);
            if (delta > 0 && currentIdx < speeds.length - 1) {
                state.speed = speeds[currentIdx + 1];
            } else if (delta < 0 && currentIdx > 0) {
                state.speed = speeds[currentIdx - 1];
            }
            updateSpeedButtons();
            saveSettings();
        };

        // Update speed button states
        const updateSpeedButtons = () => {
            speedControls.querySelectorAll('.speed-btn').forEach(btn => {
                btn.classList.toggle('active', parseInt(btn.dataset.speed, 10) === state.speed);
            });
        };

        // Handle drop zone click
        const handleDropZoneClick = async () => {
            try {
                const text = await navigator.clipboard.readText();
                if (text.trim()) {
                    processInput(text.trim());
                } else {
                    showToast('Clipboard is empty', true);
                }
            } catch (err) {
                showToast('Cannot access clipboard. Try pasting with Ctrl+V', true);
            }
        };

        // Handle drag over
        const handleDragOver = (e) => {
            e.preventDefault();
            dropZone.classList.add('drag-over');
        };

        // Handle drag leave
        const handleDragLeave = () => {
            dropZone.classList.remove('drag-over');
        };

        // Handle drop
        const handleDrop = async (e) => {
            e.preventDefault();
            dropZone.classList.remove('drag-over');

            // Check for files (text files)
            if (e.dataTransfer.files.length > 0) {
                const file = e.dataTransfer.files[0];
                if (file.type === 'text/plain' || file.name.endsWith('.txt')) {
                    const text = await file.text();
                    processInput(text);
                    return;
                }
            }

            // Check for text/URL
            const text = e.dataTransfer.getData('text/plain') || e.dataTransfer.getData('text/uri-list');
            if (text) {
                processInput(text.trim());
            }
        };

        // Handle paste - always accept new text
        const handlePaste = (e) => {
            const text = e.clipboardData.getData('text/plain');
            if (text && text.trim().length > 0) {
                e.preventDefault();
                // Stop current playback if running
                if (state.isPlaying) {
                    pause();
                }
                processInput(text.trim());
            }
        };

        // Process input (text or URL)
        const processInput = async (input) => {
            // Check if it's a URL
            if (isUrl(input)) {
                await fetchAndParseUrl(input);
            } else {
                loadText(input);
            }
        };

        // Check if input is a URL
        const isUrl = (str) => {
            try {
                const url = new URL(str);
                return url.protocol === 'http:' || url.protocol === 'https:';
            } catch {
                return false;
            }
        };

        // Fetch and parse URL content
        const fetchAndParseUrl = async (url) => {
            showLoading('Fetching article...');

            try {
                const response = await fetch(CORS_PROXY + encodeURIComponent(url));
                if (!response.ok) throw new Error('Failed to fetch URL');

                const html = await response.text();

                // Parse with Readability
                const parser = new DOMParser();
                const doc = parser.parseFromString(html, 'text/html');

                // Set base URL for relative links
                const base = doc.createElement('base');
                base.href = url;
                doc.head.appendChild(base);

                const reader = new Readability(doc);
                const article = reader.parse();

                if (article && article.textContent) {
                    loadText(article.textContent);
                } else {
                    throw new Error('Could not extract article content');
                }
            } catch (err) {
                console.error('URL fetch error:', err);
                showToast('Failed to fetch article. Try pasting the text directly.', true);
                hideLoading();
            }
        };

        // Show loading state
        const showLoading = (message) => {
            dropZone.innerHTML = `
                <div class="loading">
                    <div class="spinner"></div>
                    <div>${message}</div>
                </div>
            `;
        };

        // Hide loading state
        const hideLoading = () => {
            dropZone.innerHTML = `
                <div class="drop-zone-icon">ðŸ“–</div>
                <div class="drop-zone-text">Drop text or URL here, or click to paste</div>
                <div class="drop-zone-hint">Supports: text, URLs to articles, text files</div>
            `;
        };

        // Load text into reader
        const loadText = (text) => {
            // Clean text
            const cleanText = text
                .replace(/\s+/g, ' ')
                .trim();

            // Split into words, handling cases like "word.Word" or "end."Start"
            const rawWords = cleanText.split(' ').filter(word => word.length > 0);
            state.words = [];

            for (const word of rawWords) {
                // Split on sentence-ending punctuation followed by:
                // - Optional quote then uppercase letter (new sentence)
                // - Quote then any letter (new quoted text)
                // Handles straight and curly quotes: " ' " " ' '
                const parts = word.split(/([.!?])(?=["'""'']?[A-Z]|["'""''][a-zA-Z])/);

                if (parts.length > 1) {
                    // Recombine punctuation with preceding word
                    for (let i = 0; i < parts.length; i++) {
                        if (parts[i].length === 1 && /[.!?]/.test(parts[i])) {
                            // This is punctuation, append to previous if exists
                            if (state.words.length > 0) {
                                state.words[state.words.length - 1] += parts[i];
                            }
                        } else if (parts[i].length > 0) {
                            state.words.push(parts[i]);
                        }
                    }
                } else {
                    state.words.push(word);
                }
            }

            state.currentIndex = 0;
            state.textLoaded = true;

            if (state.words.length === 0) {
                showToast('No text found', true);
                hideLoading();
                return;
            }

            // Hide input overlay and resume banner
            inputOverlay.classList.add('hidden');
            resumeBanner.classList.add('hidden');
            clearSession();

            // Reset timer for new text
            resetTimer();

            // Update display
            updateWordCount();
            displayWord();

            // Auto-start
            togglePlayPause();
        };

        // Display current word
        const displayWord = () => {
            if (state.currentIndex >= state.words.length) {
                // End of text
                pause();
                showToast('Finished!');
                clearSession();
                return;
            }

            const word = state.words[state.currentIndex];
            const letters = splitIntoLetters(word);
            const focusIndex = getFocusIndex(word);

            // Build HTML with focus letter highlighted
            let html = '';

            for (let i = 0; i < letters.length; i++) {
                if (i === focusIndex) {
                    html += `<span class="letter focus-letter">${escapeHtml(letters[i])}</span>`;
                } else {
                    html += `<span class="letter">${escapeHtml(letters[i])}</span>`;
                }
            }

            // Reset font size before measuring
            wordDisplay.style.fontSize = '';
            wordDisplay.innerHTML = html;

            // Scale down long words to fit screen
            scaleWordToFit();

            // Position word so focus letter is centered
            positionWord(focusIndex, letters.length);

            // Update progress
            updateProgress();
        };

        // Scale word to fit within viewport
        const scaleWordToFit = () => {
            const maxWidth = window.innerWidth * 0.85;
            const currentWidth = wordDisplay.scrollWidth;

            if (currentWidth > maxWidth) {
                const scale = maxWidth / currentWidth;
                const computedStyle = window.getComputedStyle(wordDisplay);
                const currentFontSize = parseFloat(computedStyle.fontSize);
                const newFontSize = currentFontSize * scale;
                wordDisplay.style.fontSize = `${newFontSize}px`;
            }
        };

        // Split word into visual letters, keeping Dutch digraphs together
        const splitIntoLetters = (word) => {
            const result = [];
            const lower = word.toLowerCase();
            let i = 0;

            // Dutch digraphs: ij, double vowels, double consonants, diphthongs
            const digraphs = ['ij', 'aa', 'ee', 'oo', 'uu', 'ie', 'oe', 'au', 'ou', 'ei', 'eu', 'ui',
                              'bb', 'cc', 'dd', 'ff', 'gg', 'kk', 'll', 'mm', 'nn', 'pp', 'rr', 'ss', 'tt', 'vv', 'ww', 'zz', 'ch', 'ng', 'nk'];

            while (i < word.length) {
                // Check for digraph at current position
                let found = false;
                for (const di of digraphs) {
                    if (lower.substring(i, i + di.length) === di) {
                        result.push(word.substring(i, i + di.length));
                        i += di.length;
                        found = true;
                        break;
                    }
                }
                if (!found) {
                    result.push(word[i]);
                    i++;
                }
            }
            return result;
        };

        // Get the index of the focus letter (middle, or one left if even)
        const getFocusIndex = (word) => {
            const letters = splitIntoLetters(word);
            const len = letters.length;
            if (len <= 1) return 0;
            if (len % 2 === 0) {
                return Math.floor(len / 2) - 1;
            }
            return Math.floor(len / 2);
        };

        // Position word so focus letter is centered
        const positionWord = (focusIndex, totalLetters) => {
            requestAnimationFrame(() => {
                const letterElements = wordDisplay.querySelectorAll('.letter');
                if (letterElements.length === 0) return;

                // Calculate distance from word's left edge to focus letter's center
                let focusLetterCenter = 0;
                for (let i = 0; i < focusIndex; i++) {
                    focusLetterCenter += letterElements[i].offsetWidth;
                }
                focusLetterCenter += letterElements[focusIndex].offsetWidth / 2;

                // Word is centered by flexbox (word center = screen center)
                // Shift so focus letter center = screen center
                const wordWidth = wordDisplay.offsetWidth;
                const wordCenter = wordWidth / 2;
                const shift = wordCenter - focusLetterCenter;

                wordDisplay.style.transform = `translateX(${shift}px)`;
            });
        };

        // Escape HTML
        const escapeHtml = (str) => {
            const div = document.createElement('div');
            div.textContent = str;
            return div.innerHTML;
        };

        // Update word count display
        const updateWordCount = () => {
            wordCountDisplay.textContent = `${state.currentIndex + 1} / ${state.words.length}`;
        };

        // Update progress bar
        const updateProgress = () => {
            const progress = (state.currentIndex / state.words.length) * 100;
            progressBar.style.width = `${progress}%`;
            updateWordCount();
        };

        // Timer functions
        const startTimer = () => {
            if (state.timerIntervalId) return; // Already running
            state.timerStartTime = Date.now();
            state.timerIntervalId = setInterval(updateTimerDisplay, 1000);
            updateTimerDisplay();
        };

        const stopTimer = () => {
            if (state.timerIntervalId) {
                // Save elapsed time
                if (state.timerStartTime) {
                    state.timerElapsed += Date.now() - state.timerStartTime;
                }
                clearInterval(state.timerIntervalId);
                state.timerIntervalId = null;
                state.timerStartTime = null;
            }
        };

        const resetTimer = () => {
            stopTimer();
            state.timerElapsed = 0;
            state.wordsRead = 0;
            timerDisplay.textContent = '';
        };

        const updateTimerDisplay = () => {
            let totalMs = state.timerElapsed;
            if (state.timerStartTime) {
                totalMs += Date.now() - state.timerStartTime;
            }
            const totalSeconds = Math.floor(totalMs / 1000);
            const minutes = Math.floor(totalSeconds / 60);
            const seconds = totalSeconds % 60;
            const timeStr = `${minutes}:${seconds.toString().padStart(2, '0')}`;
            timerDisplay.textContent = `${state.wordsRead} Â· ${timeStr}`;
        };

        // Calculate display time for a word
        const getWordDisplayTime = (word) => {
            const baseTime = 60000 / state.speed; // ms per word at base speed
            const baseLength = 4;
            const wordLength = word.length;

            // Adjust time based on word length using square root
            // A word n times as long gets âˆšn times more display time
            let time = baseTime * Math.sqrt(wordLength / baseLength);

            // Minimum display time
            time = Math.max(time, baseTime * 0.5);

            // Extra time for end of sentence
            if (/[.!?]$/.test(word)) {
                time *= 1.5;
            }
            // Slight extra time for comma/semicolon
            else if (/[,;:]$/.test(word)) {
                time *= 1.2;
            }

            return time;
        };

        // Toggle play/pause
        const togglePlayPause = () => {
            if (state.isPlaying) {
                pause();
            } else {
                play();
            }
        };

        // Play
        const play = () => {
            if (!state.textLoaded || state.currentIndex >= state.words.length) return;

            state.isPlaying = true;
            playIcon.style.display = 'none';
            pauseIcon.style.display = 'block';
            playPauseText.textContent = 'Pause';

            startTimer();
            scheduleNextWord();
        };

        // Pause
        const pause = () => {
            state.isPlaying = false;
            playIcon.style.display = 'block';
            pauseIcon.style.display = 'none';
            playPauseText.textContent = 'Start';

            if (state.timeoutId) {
                clearTimeout(state.timeoutId);
                state.timeoutId = null;
            }

            stopTimer();
            saveSession();
        };

        // Schedule next word
        const scheduleNextWord = () => {
            if (!state.isPlaying) return;

            const word = state.words[state.currentIndex];
            const displayTime = getWordDisplayTime(word);

            // Count this word as read
            state.wordsRead++;

            state.timeoutId = setTimeout(() => {
                state.currentIndex++;
                if (state.currentIndex < state.words.length) {
                    displayWord();
                    scheduleNextWord();
                } else {
                    displayWord(); // Will show "Finished!"
                }
            }, displayTime);
        };

        // Reset reader
        const resetReader = () => {
            pause();
            resetTimer();
            state.words = [];
            state.currentIndex = 0;
            state.textLoaded = false;
            wordDisplay.innerHTML = '';
            progressBar.style.width = '0%';
            wordCountDisplay.textContent = '';
            inputOverlay.classList.remove('hidden');
            hideLoading();
            clearSession();
        };

        // Show toast message
        const showToast = (message, isError = false) => {
            toast.textContent = message;
            toast.className = 'toast' + (isError ? ' error' : '');
            toast.classList.add('show');
            setTimeout(() => toast.classList.remove('show'), 3000);
        };

        // Check URL parameter for text or URL
        const checkUrlParam = () => {
            const params = new URLSearchParams(window.location.search);
            const url = params.get('url');
            const text = params.get('text');

            if (url) {
                processInput(url);
            } else if (text) {
                processInput(text);
            }
        };

        // Initialize on load
        init();
    </script>
</body>
</html>
